"use strict";(self.webpackChunkzharii=self.webpackChunkzharii||[]).push([[2623],{96080:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var r=t(667);function a(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function o(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,r)}return t}function i(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?o(Object(t),!0).forEach((function(n){a(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):o(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,r,a=function(e,n){if(null==e)return{};var t,r,a={},o=Object.keys(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||(a[t]=e[t]);return a}(e,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(r=0;r<o.length;r++)t=o[r],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(a[t]=e[t])}return a}var l=r.createContext({}),d=function(e){var n=r.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):i(i({},n),e)),t},u=function(e){var n=d(e.components);return r.createElement(l.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return r.createElement(r.Fragment,{},n)}},p=r.forwardRef((function(e,n){var t=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),p=d(t),m=a,f=p["".concat(l,".").concat(m)]||p[m]||c[m]||o;return t?r.createElement(f,i(i({ref:n},u),{},{components:t})):r.createElement(f,i({ref:n},u))}));function m(e,n){var t=arguments,a=n&&n.mdxType;if("string"==typeof e||a){var o=t.length,i=new Array(o);i[0]=p;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,i[1]=s;for(var d=2;d<o;d++)i[d]=t[d];return r.createElement.apply(null,i)}return r.createElement.apply(null,t)}p.displayName="MDXCreateElement"},87871:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return d},toc:function(){return u},default:function(){return p}});var r=t(54570),a=t(89462),o=(t(667),t(96080)),i=["components"],s={},l="2023-06-19 In C++ 17 describe new features as a code block",d={unversionedId:"dev-good-GPT-prompts/2023-06-19-CPP-17-describe-new-language-features",id:"dev-good-GPT-prompts/2023-06-19-CPP-17-describe-new-language-features",title:"2023-06-19 In C++ 17 describe new features as a code block",description:"Date: 2023-06-19",source:"@site/docs/dev-good-GPT-prompts/2023-06-19-CPP-17-describe-new-language-features.md",sourceDirName:"dev-good-GPT-prompts",slug:"/dev-good-GPT-prompts/2023-06-19-CPP-17-describe-new-language-features",permalink:"https://blog.zharii.com/docs/dev-good-GPT-prompts/2023-06-19-CPP-17-describe-new-language-features",editUrl:"https://github.com/dzharii/dzharii.github.io/docs/dev-good-GPT-prompts/2023-06-19-CPP-17-describe-new-language-features.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Valid Word Abbreviation",permalink:"https://blog.zharii.com/docs/chatGPT/2024-01-06-Valid-Word-Abbreviation"},next:{title:"2023-02-16-Seattle-Link-Pictograms",permalink:"https://blog.zharii.com/docs/fun/2023-02-16-Seattle-Link-Pictograms"}},u=[{value:"Prompt",id:"prompt",children:[],level:2},{value:"Responses",id:"responses",children:[],level:2},{value:"Standard Library C++17",id:"standard-library-c17",children:[],level:2},{value:"C++ 20",id:"c-20",children:[],level:2},{value:"Standard Library C++20",id:"standard-library-c20",children:[],level:2}],c={toc:u};function p(e){var n=e.components,t=(0,a.Z)(e,i);return(0,o.kt)("wrapper",(0,r.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"2023-06-19-in-c-17-describe-new-features-as-a-code-block"},"2023-06-19 In C++ 17 describe new features as a code block"),(0,o.kt)("p",null,"Date: 2023-06-19"),(0,o.kt)("h2",{id:"prompt"},"Prompt"),(0,o.kt)("p",null,"Make all code cheat sheet for C++ 17 new features, for instance "),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// C++ 17 now allows multiple commands in if statement\nif (int a = Func1(), b = Func2(); a && b)\n{\n    // Do stuff with a and b.\n}\n\n// next feature ...\n")),(0,o.kt)("p",null,"generate as a continuous markdown code block. put brief explanation in the code comments only"),(0,o.kt)("h2",{id:"responses"},"Responses"),(0,o.kt)("p",null,"Certainly! Here's a cheat sheet for C++17's new features:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'// C++ 17 now allows multiple commands in if statement\nif (int a = Func1(), b = Func2(); a && b)\n{\n    // Do stuff with a and b.\n}\n\n// std::optional provides a nullable object that can conditionally hold a value\nstd::optional<int> optionalInt = GetValue();\nif (optionalInt.has_value())\n{\n    int value = optionalInt.value();\n    // Use the value\n}\n\n// Structured bindings allow unpacking of tuples and other structures\nstd::tuple<int, std::string> tuple = GetTuple();\nauto [number, text] = tuple;\n// Use number and text\n\n// Fold expressions simplify variadic templates and enable easier recursive template functions\ntemplate <typename... Args>\nbool AllTrue(Args... args)\n{\n    return (args && ...);\n}\n\n// constexpr if allows compile-time branching based on type traits or constexpr expressions\ntemplate <typename T>\nvoid Process(T value)\n{\n    if constexpr (std::is_integral_v<T>)\n    {\n        // Process integral types\n    }\n    else if constexpr (std::is_floating_point_v<T>)\n    {\n        // Process floating-point types\n    }\n    else\n    {\n        // Process other types\n    }\n}\n\n// std::filesystem provides a standardized file system library for file and directory operations\nstd::filesystem::path filePath = "/path/to/file.txt";\nif (std::filesystem::exists(filePath))\n{\n    std::filesystem::remove(filePath);\n}\n\n// New string_view literals make it easier to work with string literals as non-owning views\nusing namespace std::literals::string_view_literals;\nstd::string_view view = "Hello World"sv;\nstd::cout << view;\n\n// if and switch statements now allow initialization of variables inside their conditions\nif (auto result = SomeFunction(); result == ExpectedValue)\n{\n    // Do something\n}\n\n// Parallel algorithms make it easier to utilize multiple cores for efficient processing\nstd::vector<int> numbers = {1, 2, 3, 4, 5};\nstd::for_each(std::execution::par, numbers.begin(), numbers.end(), [](int& n) {\n    n *= 2;\n});\n\n// New attributes like [[maybe_unused]] and [[nodiscard]] provide additional control and annotations\n[[maybe_unused]] int unusedVariable;\n[[nodiscard]] int GetValue();\n\n// constexpr lambdas allow lambda functions to be evaluated at compile-time\nconstexpr auto square = [](int x) { return x * x; };\nint result = square(5); // Evaluated at compile-time\n\n// Class template argument deduction allows automatic deduction of template arguments from constructor arguments\nstd::vector numbers = {1, 2, 3, 4}; // Deduced as std::vector<int>\n\n// inline variables provide an alternative to static constants in headers\ninline constexpr int MaxValue = 100;\n\n// Non-type template parameters can now be deduced in more scenarios\ntemplate <auto Value>\nvoid ProcessValue()\n{\n    // Process the value\n}\nProcessValue<42>(); // Deduced as ProcessValue<42>()\n\n// New standard attributes like [[fallthrough]] and [[likely]]/[[unlikely]] provide better control flow annotations\nswitch (value)\n{\n    case 1:\n        [[fallthrough]];\n    case 2:\n        // Do something for case 1 and 2\n        break;\n    case 3:\n        [[unlikely]];\n        // Do something for case 3\n        break;\n    default:\n        [[likely]];\n        // Do something for other cases\n        break;\n}\n\n// Other features include more constexpr improvements, if constexpr in lambdas, structured bindings in if\n\n statements, and more.\n')),(0,o.kt)("p",null,"These are just some of the new features introduced in C++17. Each feature provides enhancements and improvements to make C++ programming more efficient and expressive."),(0,o.kt)("p",null,"Certainly! Here are some of the new features introduced in C++20 compared to C++17:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'// C++20 introduces lambdas in unevaluated contexts, such as type traits\ntemplate <typename T>\nconstexpr bool IsPointer = []() {\n    if constexpr (std::is_pointer_v<T>) {\n        return true;\n    } else {\n        return false;\n    }\n}();\n\n// Concepts provide a way to express compile-time predicates for template arguments\ntemplate <typename T>\nconcept Integral = std::is_integral_v<T>;\n\ntemplate <Integral T>\nvoid Process(T value) {\n    // Process integral types\n}\n\n// Three-way comparisons simplify the implementation of comparison operators\nstruct Person {\n    std::string name;\n\n    auto operator<=>(const Person& other) const = default;\n};\n\n// Coroutines enable the use of lightweight cooperative multitasking\n#include <coroutine>\n\nstruct Task {\n    struct promise_type {\n        Task get_return_object() { return {}; }\n        std::suspend_never initial_suspend() { return {}; }\n        std::suspend_never final_suspend() noexcept { return {}; }\n        void return_void() {}\n        void unhandled_exception() {}\n    };\n};\n\n// Ranges provide a standardized way to work with sequences of values\n#include <ranges>\n\nstd::vector<int> numbers = {1, 2, 3, 4, 5};\nauto evenNumbers = numbers | std::views::filter([](int n) { return n % 2 == 0; });\n\n// Concepts and ranges can be combined to express complex predicates on ranges\ntemplate <typename T>\nconcept EvenNumber = std::integral<T> && (T{} % 2 == 0);\n\nauto evenNumbers = numbers | std::views::filter(EvenNumber{});\n\n// Modules provide a new modularization system for better code organization and build times\nimport <iostream>;\n\nint main() {\n    std::cout << "Hello, Modules!";\n    return 0;\n}\n\n// Calendar and time zone support with the <chrono> library\n#include <chrono>\n#include <iostream>\n\nint main() {\n    auto currentTime = std::chrono::system_clock::now();\n    std::cout << "Current time: " << std::chrono::format("%Y-%m-%d %H:%M:%S", currentTime);\n    return 0;\n}\n\n// Additional standard attributes like likely and unlikely provide better control flow hints\n[[likely]] void FastPath() {\n    // Optimized code path\n}\n\n[[unlikely]] void SlowPath() {\n    // Less optimized code path\n}\n\n// Simplified capture of this in lambdas\nstruct Foo {\n    void DoSomething() {\n        [self = *this]() {\n            // Capture of this as a value\n            self.MemberFunction();\n        }();\n    }\n\n    void MemberFunction() {\n        // Do something\n    }\n};\n\n// consteval allows evaluation of functions at compile-time\nconsteval int Square(int x) {\n    return x * x;\n}\n\nint main() {\n    constexpr int result = Square(5); // Evaluated at compile-time\n    return 0;\n}\n')),(0,o.kt)("h2",{id:"standard-library-c17"},"Standard Library C++17"),(0,o.kt)("p",null,"Certainly! Here are some of the key changes and additions to the C++ Standard Library in C++17:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'// New headers\n#include <optional>   // Provides a container for optional values\n#include <variant>    // Introduces a type-safe union of types\n#include <any>        // Introduces a container for single values of any type\n#include <string_view> // Introduces non-owning string-like objects\n#include <filesystem> // Provides facilities for manipulating file systems\n\n// std::optional allows representing optional values without using pointers\nstd::optional<int> GetValue() {\n    if (/* some condition */) {\n        return 42;\n    }\n    return std::nullopt; // No value\n}\n\n// std::variant provides a type-safe union of types\nstd::variant<int, double, std::string> GetValue() {\n    if (/* some condition */) {\n        return 42;\n    } else if (/* some other condition */) {\n        return 3.14;\n    } else {\n        return "Hello";\n    }\n}\n\n// std::any is a container for single values of any type\nstd::any value = 42;\nvalue = 3.14;\nvalue = "Hello";\n\n// std::string_view provides non-owning string-like objects\nvoid PrintString(std::string_view str) {\n    std::cout << str;\n}\n\n// std::filesystem provides facilities for manipulating file systems\n#include <filesystem>\nnamespace fs = std::filesystem;\nfs::path path = fs::current_path();\nif (fs::exists(path)) {\n    fs::rename(path, "new_name.txt");\n}\n\n// Parallel algorithms\n#include <algorithm>\n#include <execution>\nstd::vector<int> data = {5, 2, 8, 1, 7};\nstd::sort(std::execution::par, data.begin(), data.end());\n\n// Structured bindings\nstd::map<std::string, int> scores = {{"Alice", 100}, {"Bob", 85}};\nfor (const auto& [name, score] : scores) {\n    std::cout << name << ": " << score << std::endl;\n}\n\n// New Standard Library functions\nstd::string str = "Hello, World!";\nif (std::all_of(str.begin(), str.end(), ::isalpha)) {\n    std::cout << "The string contains only alphabetic characters." << std::endl;\n}\n\n// std::scoped_lock provides a convenient way to acquire multiple locks simultaneously\nstd::mutex mutex1, mutex2;\nstd::scoped_lock lock(mutex1, mutex2); // Locks both mutexes\n\n// Improved smart pointers\nstd::shared_ptr<int> ptr = std::make_shared<int>(42);\nstd::weak_ptr<int> weakPtr = ptr;\n\n// Emplacement in containers\nstd::vector<int> numbers;\nnumbers.emplace_back(42); // Constructs the element in-place\n\n// Parallelism TS (Technical Specification)\n#include <experimental/algorithm>\nstd::experimental::parallel::sort(data.begin(), data.end());\n\n// Filesystem TS (Technical Specification)\n#include <experimental/filesystem>\nnamespace fs = std::experimental::filesystem;\nfs::path path = fs::current_path();\nif (fs::exists(path)) {\n    fs::rename(path, "new_name.txt");\n}\n')),(0,o.kt)("p",null,"These are some of the major changes and additions to the C++ Standard Library in C++17. These additions provide developers with powerful new tools, such as optional values, variant types, filesystem manipulation, parallel algorithms, and improved smart pointers, making it easier to write modern, expressive, and efficient C++ code."),(0,o.kt)("h2",{id:"c-20"},"C++ 20"),(0,o.kt)("p",null,"These are just some of the new features added in C++20, building upon the enhancements introduced in C++17. Each feature brings additional capabilities and improvements to the C++ language, empowering developers to write more expressive, efficient, and modern code."),(0,o.kt)("p",null,"Certainly! Here are the remaining features added in C++20 compared to C++17:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'// Modules provide a new modularization system for better code organization and build times\nimport <iostream>;\n\nint main() {\n    std::cout << "Hello, Modules!";\n    return 0;\n}\n\n// Calendar and time zone support with the <chrono> library\n#include <chrono>\n#include <iostream>\n\nint main() {\n    auto currentTime = std::chrono::system_clock::now();\n    std::cout << "Current time: " << std::chrono::format("%Y-%m-%d %H:%M:%S", currentTime);\n    return 0;\n}\n\n// Additional standard attributes like likely and unlikely provide better control flow hints\n[[likely]] void FastPath() {\n    // Optimized code path\n}\n\n[[unlikely]] void SlowPath() {\n    // Less optimized code path\n}\n\n// Simplified capture of this in lambdas\nstruct Foo {\n    void DoSomething() {\n        [self = *this]() {\n            // Capture of this as a value\n            self.MemberFunction();\n        }();\n    }\n\n    void MemberFunction() {\n        // Do something\n    }\n};\n\n// consteval allows evaluation of functions at compile-time\nconsteval int Square(int x) {\n    return x * x;\n}\n\nint main() {\n    constexpr int result = Square(5); // Evaluated at compile-time\n    return 0;\n}\n\n// Improved constexpr for lambda expressions\nconstexpr auto square = [](int x) { return x * x; };\n\n// Polymorphic lambdas with auto parameters\nauto printValue = [](const auto& value) {\n    std::cout << value << std::endl;\n};\n\n// Attribute syntax for namespaces and enumerators\n[[namespace::foo]]\nnamespace bar {\n    enum class [[enumerator]] Color { Red, Green, Blue };\n}\n\n// Three-way comparison operator for std::string_view\nstd::string_view str1 = "Hello";\nstd::string_view str2 = "World";\nif (str1 <=> str2 > 0) {\n    std::cout << "str1 is greater than str2" << std::endl;\n}\n\n// Standardized mathematical constants\n#include <numbers>\ndouble pi = std::numbers::pi;\ndouble e = std::numbers::e;\n\n// New standard attributes to enforce constraints on functions\n[[nodiscard]] int GetValue() {\n    return 42;\n}\n\n// Synchronized output with std::osyncstream\n#include <iostream>\n#include <fstream>\n\nint main() {\n    std::ofstream file("output.txt");\n    std::osyncstream syncedStream(file);\n    syncedStream << "Hello, synchronized output!";\n    return 0;\n}\n')),(0,o.kt)("p",null,"These are the remaining features added in C++20. Each feature brings new functionality, syntax improvements, and better control over code organization, execution, and output. Together, these features enhance the power and expressiveness of the C++ language, enabling developers to write more efficient, maintainable, and modern code."),(0,o.kt)("h2",{id:"standard-library-c20"},"Standard Library C++20"),(0,o.kt)("p",null,"Certainly! Here are some of the major changes and additions to the C++ Standard Library in C++20:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-cpp"},'// Ranges library\n#include <ranges>\nstd::vector<int> numbers = {1, 2, 3, 4, 5};\nauto filtered = numbers | std::views::filter([](int n) { return n % 2 == 0; });\nfor (int n : filtered) {\n    std::cout << n << \' \';\n}\n\n// Three-way comparisons\n#include <compare>\nstruct MyClass {\n    int value;\n    auto operator<=>(const MyClass&) const = default;\n};\n\n// Calendar and time zone library\n#include <chrono>\nauto now = std::chrono::system_clock::now();\nauto tp = std::chrono::clock_cast<std::chrono::local_days>(now);\nauto ymd = std::chrono::year_month_day(tp);\n\n// Coroutines\n#include <coroutine>\n#include <iostream>\nstruct generator {\n    struct promise_type {\n        int current_value;\n\n        generator get_return_object() { return generator{std::coroutine_handle<promise_type>::from_promise(*this)}; }\n        std::suspend_always initial_suspend() { return {}; }\n        std::suspend_always final_suspend() noexcept { return {}; }\n        void unhandled_exception() {}\n        std::suspend_always yield_value(int value) {\n            current_value = value;\n            return {};\n        }\n    };\n\n    bool move_next() { return coro.resume(); }\n    int current_value() { return coro.promise().current_value; }\n\n    explicit generator(std::coroutine_handle<promise_type> h) : coro(h) {}\n    ~generator() { if (coro) coro.destroy(); }\n\nprivate:\n    std::coroutine_handle<promise_type> coro;\n};\n\ngenerator fibonacci(int n) {\n    int a = 0, b = 1;\n    while (n-- > 0) {\n        co_yield a;\n        auto old_a = a;\n        a = b;\n        b += old_a;\n    }\n}\n\nint main() {\n    for (int fib : fibonacci(10)) {\n        std::cout << fib << \' \';\n    }\n}\n\n// Concepts\ntemplate <typename T>\nconcept Integral = std::is_integral_v<T>;\n\ntemplate <Integral T>\nT add(T a, T b) {\n    return a + b;\n}\n\n// Synchronized output with std::osyncstream\n#include <iostream>\n#include <fstream>\nstd::osyncstream synchronized_out(std::cout);\n\nvoid thread_function() {\n    synchronized_out << "Hello from thread!" << std::endl;\n}\n\n// Improved smart pointers\nstd::unique_ptr<int[]> array = std::make_unique<int[]>(10);\nstd::shared_ptr<int[]> sharedArray = std::make_shared<int[]>(10);\n\n// New Standard Library functions\nstd::vector<int> numbers = {1, 2, 3, 4, 5};\nauto it = std::find(numbers.begin(), numbers.end(), 3);\nif (it != numbers.end()) {\n    std::cout << "Found 3 at position " << std::distance(numbers.begin(), it) << std::endl;\n}\n\n// Random number generation\n#include <random>\nstd::random_device rd;\nstd::mt19937 gen(rd());\nstd::uniform_int_distribution<> dis(1, 6);\nint random_number = dis(gen);\n\n// Extended file system features\n#include <filesystem>\nstd::filesystem::path filePath = "path/to/file.txt";\nstd::filesystem::file_time_type lastWriteTime = std::filesystem::last_write_time(filePath);\n\n// Calendar and time zone library\n#include <chrono>\nauto now = std::chrono::system_clock::\n\nnow();\nauto tp = std::chrono::clock_cast<std::chrono::local_days>(now);\nauto ymd = std::chrono::year_month_day(tp);\n')),(0,o.kt)("p",null,"These are some of the major changes and additions to the C++ Standard Library in C++20. These additions provide developers with powerful tools for working with ranges, three-way comparisons, coroutines, concepts, synchronized output, improved smart pointers, extended file system features, and enhanced calendar and time zone capabilities. These additions aim to make C++ code more expressive, efficient, and easier to work with."))}p.isMDXComponent=!0}}]);