"use strict";(self.webpackChunkzharii=self.webpackChunkzharii||[]).push([[3783],{96080:function(e,t,a){a.d(t,{Zo:function(){return c},kt:function(){return d}});var n=a(667);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var s=n.createContext({}),p=function(e){var t=n.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},c=function(e){var t=p(e.components);return n.createElement(s.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},u=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,s=e.parentName,c=o(e,["components","mdxType","originalType","parentName"]),u=p(a),d=r,k=u["".concat(s,".").concat(d)]||u[d]||m[d]||i;return a?n.createElement(k,l(l({ref:t},c),{},{components:a})):n.createElement(k,l({ref:t},c))}));function d(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=u;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o.mdxType="string"==typeof e?e:r,l[1]=o;for(var p=2;p<i;p++)l[p]=a[p];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}u.displayName="MDXCreateElement"},45093:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return o},contentTitle:function(){return s},metadata:function(){return p},toc:function(){return c},default:function(){return u}});var n=a(54570),r=a(89462),i=(a(667),a(96080)),l=["components"],o={},s="dev-c99",p={unversionedId:"dev-c99",id:"dev-c99",title:"dev-c99",description:"Date: 2025-09-03",source:"@site/docs/dev-c99.md",sourceDirName:".",slug:"/dev-c99",permalink:"/docs/dev-c99",editUrl:"https://github.com/dzharii/dzharii.github.io/docs/dev-c99.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"dev-c99-video-content-creators",permalink:"/docs/dev-c99-video-content-creators"},next:{title:"dev-cpp-snippets",permalink:"/docs/dev-cpp-snippets"}},c=[{value:"Compilation and warnings",id:"compilation-and-warnings",children:[],level:2},{value:"Video",id:"video",children:[],level:2},{value:"C99 Reimplement this world!",id:"c99-reimplement-this-world",children:[],level:2},{value:"Dev C Articles",id:"dev-c-articles",children:[],level:2},{value:"Books",id:"books",children:[],level:2},{value:"RSS",id:"rss",children:[],level:2},{value:"Dev C Tools",id:"dev-c-tools",children:[],level:2},{value:"Dev C Libs",id:"dev-c-libs",children:[{value:"Net",id:"net",children:[],level:3},{value:"C language development",id:"c-language-development",children:[],level:3},{value:"SIMD",id:"simd",children:[],level:3}],level:2}],m={toc:c};function u(e){var t=e.components,o=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,n.Z)({},m,o,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"dev-c99"},"dev-c99"),(0,i.kt)("p",null,"Date: 2025-09-03"),(0,i.kt)("h2",{id:"compilation-and-warnings"},"Compilation and warnings"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"# Clang on Unix-like systems\nclang -std=c99 -Wall -Wextra -Werror -O2 -g main.c -o main\n")),(0,i.kt)("p",null,"This compiles main.c as C99 with Clang, enables many warnings (-Wall), adds extra diagnostics (-Wextra), and promotes all warnings to errors (-Werror). -O2 optimizes, -g keeps symbols for debugging, and -o main names the output.\n",(0,i.kt)("a",{parentName:"p",href:"https://clang.llvm.org/docs/CommandGuide/clang.html"},"Clang Command Guide")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"# GCC on Unix-like systems\ngcc -std=c99 -Wall -Wextra -Werror -O2 -g main.c -o main\n")),(0,i.kt)("p",null,"This compiles main.c as C99 with GCC. -Wall, -Wextra, and -Werror control diagnostics; -O2 and -g set optimization and debug info; -o names the output.\n",(0,i.kt)("a",{parentName:"p",href:"https://gcc.gnu.org/onlinedocs/gcc-14.1.0/gcc/Warning-Options.html"},"GCC Warning Options")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bat"},":: MSVC cl.exe on Windows Developer Command Prompt\n:: Note: cl.exe does not have a C99 mode switch. It can compile C code, but full C99 conformance is not guaranteed.\ncl /TC /W4 /WX /Zi /O2 main.c /Fe:main.exe\n")),(0,i.kt)("p",null,"This compiles main.c as C with MSVC. /TC forces C mode, /W4 is a high warning level, /WX treats warnings as errors, /Zi emits PDB debug info, /O2 optimizes, and /Fe names the exe. For strict C99 needs on Windows, use Clang or GCC toolchains.\n",(0,i.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/cpp/build/reference/compiler-option-warning-level?view=msvc-170"},"MSVC Warning Levels"),"\n",(0,i.kt)("a",{parentName:"p",href:"https://learn.microsoft.com/en-us/cpp/c-language/c-language-reference?view=msvc-170"},"MSVC C Language Conformance Notes")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-bat"},":: Clang-cl on Windows (MSVC-compatible driver, still C99 frontend)\nclang-cl /std:c99 /W4 /WX /Zi /O2 main.c /Fe:main.exe\n")),(0,i.kt)("p",null,"This uses Clang on Windows with MSVC-style flags, targeting C99. You get Clang diagnostics and codegen while integrating with MSVC-style tools and linkers.\n",(0,i.kt)("a",{parentName:"p",href:"https://clang.llvm.org/docs/UsersManual.html#clang-cl"},"Clang-cl User Guide")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-sh"},"# Tiny C Compiler (TCC)\n# TCC is a C compiler; it does not compile C++ and has a smaller warning set.\ntcc -std=c99 -Wall -Werror main.c -o main\n")),(0,i.kt)("p",null,"This compiles main.c as C99 with TCC. -Wall enables its warnings and -Werror treats them as errors. TCC does not support -Wextra.\n",(0,i.kt)("a",{parentName:"p",href:"https://bellard.org/tcc/tcc-doc.html"},"Tiny C Compiler Reference")),(0,i.kt)("h2",{id:"video"},"Video"),(0,i.kt)("p",null,"2025-08-01 ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=443UNeGrFoM"},"How I program C - YouTube")," { ",(0,i.kt)("a",{parentName:"p",href:"http://www.youtube.com"},"www.youtube.com")," }"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20250801102620753",src:a(35565).Z,width:"1374",height:"861"}),"\n",(0,i.kt)("strong",{parentName:"p"},"Speaker")," Eskil Steenberg \u2013 game-engine and tools developer (Quel Solaar)\n",(0,i.kt)("strong",{parentName:"p"},"Recording")," Seattle, Oct 2016 (2 h 11 m)"),(0,i.kt)("p",{parentName:"blockquote"},"Key themes"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Results first, control later \u2013 why explicit memory management, crashes, and compiler errors are desirable."),(0,i.kt)("li",{parentName:"ul"},"Minimise technology footprint \u2013 target C89/C90, wrap every dependency, zero un-wrapped libraries."),(0,i.kt)("li",{parentName:"ul"},"Code is for humans \u2013 long descriptive names, uniform naming schemes, wide functions, avoid cleverness (e.g. operator overloading)."),(0,i.kt)("li",{parentName:"ul"},"Favour simple languages plus strong tooling \u2013 write parsers, debuggers, doc generators yourself."),(0,i.kt)("li",{parentName:"ul"},"Memory mastery \u2013 pointers as arrays, alignment and padding, struct packing, cache-friendly dynamic arrays + ",(0,i.kt)("inlineCode",{parentName:"li"},"realloc"),", dangers of linked lists."),(0,i.kt)("li",{parentName:"ul"},"API design \u2013 opaque handles (void *), start with public interface, isolate implementation, macro-assisted debug wrappers (",(0,i.kt)("inlineCode",{parentName:"li"},"__FILE__"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"__LINE__"),")."),(0,i.kt)("li",{parentName:"ul"},"Build a mountain \u2013 own your stack, keep technical debt near zero, rewrite early."),(0,i.kt)("li",{parentName:"ul"},"UI toolkit pattern \u2013 single pass, stateless widgets keyed by pointer IDs; layout and hit-testing resolved internally."),(0,i.kt)("li",{parentName:"ul"},"Tools and snippets \u2013 Carmack inverse-sqrt; xorshift32 PRNG; GFlags page-guarding for memory bugs; Seduce UI; Testify binary packer; Ministry of Flat un-wrapper.")),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Talk structure in order of appearance")),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"Motivation and philosophy"),(0,i.kt)("li",{parentName:"ul"},"Results vs control; garbage collection vs manual ",(0,i.kt)("inlineCode",{parentName:"li"},"free")),(0,i.kt)("li",{parentName:"ul"},"Small footprint and dependency wrapping"),(0,i.kt)("li",{parentName:"ul"},"Naming conventions and formatting policies"),(0,i.kt)("li",{parentName:"ul"},"Crashes and compiler errors as friends"),(0,i.kt)("li",{parentName:"ul"},"Macros: when to use, when to avoid"),(0,i.kt)("li",{parentName:"ul"},"Deep dive: pointers, arrays, structs, alignment, packed allocations"),(0,i.kt)("li",{parentName:"ul"},"Cache-aware data structures; ",(0,i.kt)("inlineCode",{parentName:"li"},"realloc")," growth patterns; backwards remove"),(0,i.kt)("li",{parentName:"ul"},"API style with opaque handles; object orientation in C"),(0,i.kt)("li",{parentName:"ul"},"Memory-debug and binary-packing helpers using ",(0,i.kt)("inlineCode",{parentName:"li"},"__FILE__")," ",(0,i.kt)("inlineCode",{parentName:"li"},"__LINE__")),(0,i.kt)("li",{parentName:"ul"},"UI toolkit design example (Seduce)"),(0,i.kt)("li",{parentName:"ul"},"Build-your-own-tools mindset; \u201cbuild a mountain\u201d analogy"),(0,i.kt)("li",{parentName:"ul"},"Closing resources and project links"))),(0,i.kt)("p",null,"2025-08-01 ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=xND0t1pr3KY"},"C Programming Full Course for free \u2699\ufe0f (2025) - YouTube")," {",(0,i.kt)("a",{parentName:"p",href:"http://www.youtube.com%7D"},"www.youtube.com}")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20250801103430609",src:a(48322).Z,width:"793",height:"574"}))),(0,i.kt)("p",null,"2025-08-02 ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=eh8zBTTgRn4"},"Go from mid-level to advanced C programmer in two hours - YouTube")," {",(0,i.kt)("a",{parentName:"p",href:"http://www.youtube.com%7D"},"www.youtube.com}")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20250801230639700",src:a(71480).Z,width:"1182",height:"924"}))),(0,i.kt)("p",null,"2025-08-02 ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=rJrd2QMVbGM"},"C Programming and Memory Management - Full Course - YouTube")," {",(0,i.kt)("a",{parentName:"p",href:"http://www.youtube.com%7D"},"www.youtube.com}")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'Interesting, "Boot Dev", known for very annoying ads, also have some quality content'),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20250801230857693",src:a(90482).Z,width:"1228",height:"706"}))),(0,i.kt)("p",null,"2025-08-02 ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=D1bsg8wkZzo"},"I'm Building C with C without CMake - YouTube")," {",(0,i.kt)("a",{parentName:"p",href:"http://www.youtube.com%7D"},"www.youtube.com}")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20250801233701958",src:a(2462).Z,width:"1207",height:"687"}))),(0,i.kt)("p",null,"2025-08-02 ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=9UIIMBqq1D4"},"Tips for C Programming - YouTube")," {",(0,i.kt)("a",{parentName:"p",href:"http://www.youtube.com%7D"},"www.youtube.com}")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20250802105718241",src:a(97917).Z,width:"1235",height:"705"}))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Topics covered")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"C in context: history, loadbearing role, perception vs practice"),(0,i.kt)("li",{parentName:"ul"},"C versions: C89 vs C99, syntax and QoL differences"),(0,i.kt)("li",{parentName:"ul"},"Compiler discipline: -std, -Wall, -Werror, -save-temps"),(0,i.kt)("li",{parentName:"ul"},"Project organization: headers vs single translation unit"),(0,i.kt)("li",{parentName:"ul"},"Debugging fundamentals: segfault model, call stacks, IDE debuggers"),(0,i.kt)("li",{parentName:"ul"},"Memory corruption and ASan: off-by-one, red zones, -fsanitize=address"),(0,i.kt)("li",{parentName:"ul"},"Arrays with length and capacity, bounds-checked access"),(0,i.kt)("li",{parentName:"ul"},"Generics tradeoffs in C: per-type code, macros, codegen"),(0,i.kt)("li",{parentName:"ul"},"Strings with explicit length, slices, avoiding standard libc pitfalls"),(0,i.kt)("li",{parentName:"ul"},"Pointers vs indices: relocation safety, bounds checks, serialization, generational indices"),(0,i.kt)("li",{parentName:"ul"},"Memory management by lifetime: static, scope, task; arenas for task-scoped data")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"All examples referenced")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"C89 quirks: declare locals at top, positional struct init, type sizes vary"),(0,i.kt)("li",{parentName:"ul"},"C99 features: mixed declarations, designated initializers, stdint.h types, compound literals, // comments"),(0,i.kt)("li",{parentName:"ul"},"Compiler flags: -std=c99, -Wall, -Werror, -save-temps, -fsanitize=address"),(0,i.kt)("li",{parentName:"ul"},"Include behavior: literal paste, unity build via including .c files"),(0,i.kt)("li",{parentName:"ul"},"Segfault demo: dereference NULL, debugger halts on exact line"),(0,i.kt)("li",{parentName:"ul"},"Off-by-one bug: i <= count - 1 writes 1 past end, ASan catches"),(0,i.kt)("li",{parentName:"ul"},"Bounds-checked array: struct with length and capacity, get function"),(0,i.kt)("li",{parentName:"ul"},"Strings with length: slice without copying, avoid strlen pitfalls"),(0,i.kt)("li",{parentName:"ul"},"Indices not pointers: smaller references, resize-safe, serialize-friendly"),(0,i.kt)("li",{parentName:"ul"},"Arenas: one big alloc per task, one free, faster and simpler")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Small examples, close to the talk")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// C99: declare where used, loop index scoped to loop\nfor (int i = 0; i < n; i++) { /* ... */ }\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// C99 designated initializer\ntypedef struct { int id; const char *name; int age; } User;\nUser u = { .name = "Ada", .age = 36, .id = 1 };  // order independent\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Fixed-width and pointer-sized integers from stdint.h\n#include <stdint.h>\nuint32_t a = 0;\nuintptr_t pbits = (uintptr_t)some_ptr;  // big enough to hold a pointer\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Compiler discipline\n// clang -std=c99 -Wall -Werror -O2 main.c\n// clang -std=c99 -Wall -Werror -save-temps -O0 main.c\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Unity build: single translation unit\n// main.c\n#include "math.c"\n#include "strings.c"\nint main(void) { return app_run(); }\n// clang -std=c99 -Wall -Werror -O2 main.c\n')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Segfault demo with debugger\nint *p = 0;            // NULL\nint x = *p;            // debugger halts here with SIGSEGV\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Off-by-one corruption; ASan will flag the write past end\n// clang -std=c99 -fsanitize=address -g oob.c -o oob\nint *v = malloc(sizeof(int) * 10);\nfor (int i = 0; i <= 9; i++) v[i] = i;  // OK\nv[10] = 42;                             // ASan error: heap-buffer-overflow\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Bounds-checked dynamic array, minimal\ntypedef struct { size_t len; size_t cap; int *data; } IntArray;\n\nstatic inline int int_array_get(const IntArray *a, size_t i) {\n    if (i >= a->len) { __builtin_trap(); return 0; }  // debug break\n    return a->data[i];\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// String with explicit length and slicing\ntypedef struct { const char *ptr; size_t len; } Str;\n\nstatic inline Str str_slice(Str s, size_t off, size_t n) {\n    if (off > s.len) { __builtin_trap(); return (Str){0}; }\n    if (n > s.len - off) n = s.len - off;\n    return (Str){ s.ptr + off, n };\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Index over pointer for stable references\ntypedef struct { int id; /* ... */ } User;\ntypedef struct { size_t len; size_t cap; User *data; } UserArray;\n\ntypedef struct { uint32_t user_index; } Session;  // 32-bit index ref\n\nstatic inline User *user_from_index(UserArray *ua, uint32_t idx) {\n    if (idx >= ua->len) { __builtin_trap(); return 0; }\n    return &ua->data[idx];\n}\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Arena allocator sketch for task lifetime\ntypedef struct { uint8_t *base; size_t used; size_t cap; } Arena;\n\nvoid *arena_alloc(Arena *a, size_t n, size_t align) {\n    size_t p = (a->used + (align - 1)) & ~(align - 1);\n    if (p + n > a->cap) return 0;\n    void *ptr = a->base + p;\n    a->used = p + n;\n    return ptr;\n}\n// Create once per task with a single malloc; free once when task ends.\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Compound literal + designated init to pass a struct inline\ntypedef struct { int x, y; } Pt;\nvoid draw_point(Pt p);\ndraw_point((Pt){ .x = 10, .y = 20 });\n")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// // single-line comments are valid in C99\n// Use them freely for clarity.\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"C is loadbearing tech. C99 removes unnecessary pain. I lock the compiler down with -Wall and -Werror. I keep builds simple with a unity build when it fits. I never chase blind crashes; I run a debugger and ASan so memory bugs surface at the line, not in production. I wrap arrays with length and bounds, and I carry string lengths so slices are cheap and safe. I store indices instead of pointers so my data survives resizes and serializes cleanly. I allocate by lifetime and free by lifetime with arenas. With these habits, C turns from scary to sharp.")),(0,i.kt)("p",null,"2025-09-28 ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=lLv1s7rKeCM"},"Programming in Modern C with a Sneak Peek into C23 - Dawid Zalewski - ACCU 2023 - YouTube")," { ",(0,i.kt)("a",{parentName:"p",href:"http://www.youtube.com"},"www.youtube.com")," }"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20250928150824455",src:a(40014).Z,width:"1396",height:"741"})),(0,i.kt)("hr",{parentName:"blockquote"}),(0,i.kt)("p",{parentName:"blockquote"},"A high-level tour of ",(0,i.kt)("em",{parentName:"p"},"Programming in Modern C with a Sneak Peek into C23"),"  (by Dawid Zalewski) shows how C remains alive and evolving. The talk focuses on practical, post-C99 techniques, especially useful in systems and embedded work. It demonstrates idioms that improve clarity, safety, and ergonomics without giving up low-level control."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Topics covered")),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Modern initialization"),"\nBrace and designated initializers, empty initialization ",(0,i.kt)("inlineCode",{parentName:"p"},"{}")," in C23, and mixed positional and designated forms."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Arrays"),"\nArray designators, rules for inferred array size, and guidance on when to avoid variable-length arrays as storage while still using VLA syntax to declare function parameter bounds."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Pointer and API contracts"),"\nSized array parameters ",(0,i.kt)("inlineCode",{parentName:"p"},"T a[n]"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"static")," qualifiers like ",(0,i.kt)("inlineCode",{parentName:"p"},"T a[static 3]")," to require valid elements, and ",(0,i.kt)("inlineCode",{parentName:"p"},"const char *static 1")," to enforce non-null strings."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Multidimensional data"),"\nStrongly typed pointers to VLA-shaped arrays for natural ",(0,i.kt)("inlineCode",{parentName:"p"},"a[i][j]")," indexing and safer ",(0,i.kt)("inlineCode",{parentName:"p"},"sizeof")," expressions."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Compound literals"),"\nCreating unnamed lvalues to reassign structs, pass inline structs to functions, and zero objects succinctly."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Macro patterns"),"\nNamed-argument style wrappers around compound literals, simple defaults, ",(0,i.kt)("inlineCode",{parentName:"p"},"_Generic")," for ad-hoc overloading by type, and a macro trick for argument-count dispatch."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Memory layout"),"\nFlexible array members for allocating a header plus payload in one contiguous block, reducing double-allocation pitfalls."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"C23 highlights"),"\nNew keywords for ",(0,i.kt)("inlineCode",{parentName:"p"},"bool"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"true"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"false"),", the ",(0,i.kt)("inlineCode",{parentName:"p"},"nullptr")," constant, ",(0,i.kt)("inlineCode",{parentName:"p"},"auto")," type inference in specific contexts, a note on ",(0,i.kt)("inlineCode",{parentName:"p"},"constexpr"),", and current compiler support caveats.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'/*\n    Modern C23-leaning "vector" demo with annotations.\n    ASCII only.\n    Assumption: compiler supports C23 and earlier C99 features referenced.\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* C23: bool/true/false are keywords; stdbool.h not required in C23. */\nbool vec_create(struct vector **vec /* C99: [static 1] on pointer parameter */,\n                size_t cap);\n\ntypedef struct vector {\n    size_t capacity;\n    size_t size;\n    double data[];      /* C99: flexible array member */\n} vector;\n\n/* forward */\nvoid dump_vec(vector const * const v);\n\n/*\n    Create a vector with at least cap elements.\n\n    Features used and standard origin:\n      - C99: designated initializers in compound literal assignment.\n      - C99: array parameter qualifier [static 1] to express non-null, valid storage.\n      - C99: VLA type in sizeof, e.g., sizeof(double[cap]).\n      - C23: bool, true/false keywords.\n      - C23: nullptr keyword.\n      - C23: constexpr object.\n*/\nbool vec_create(vector **vec /* C99: [static 1] contract */, size_t cap) {\n    if (vec == nullptr) {          /* C23: nullptr keyword */\n        return false;\n    }\n\n    constexpr size_t DEF_CAP = 16; /* C23: constexpr object */\n    cap = (cap == 0) ? DEF_CAP : cap;\n\n    /*\n        One contiguous allocation:\n          - sizeof *v covers the header up to data[].\n          - sizeof(double[cap]) uses a VLA type (C99) to size the payload.\n    */\n    vector *v = malloc(sizeof *v + sizeof(double[cap]));\n    if (v == nullptr) {\n        *vec = nullptr;\n        return false;\n    }\n\n    /* C99: compound literal with designated initializers to set the header. */\n    *v = (vector){\n        .capacity = cap,\n        .size = 0\n        /* data[] is the flexible member; no header field to set here */\n    };\n\n    *vec = v;\n    return true;\n}\n\n/* trivial filler for demo output */\nstatic void vec_fill_sequential(vector *v) {\n    size_t n = v->capacity < 8 ? v->capacity : 8;\n    for (size_t i = 0; i < n; ++i) {\n        v->data[i] = (double)i;\n    }\n    v->size = n;\n}\n\nvoid dump_vec(vector const * const v) {\n    printf("vector at %p\\n", (void*)v);\n    printf("  capacity = %zu, size = %zu\\n", v->capacity, v->size);\n    size_t n = v->size < 8 ? v->size : 8;\n    for (size_t i = 0; i < n; ++i) {\n        printf("  data[%zu] = %g\\n", i, v->data[i]);\n    }\n}\n\nint main(void) {\n    vector *vec = nullptr;          /* C23: nullptr keyword */\n\n    if (vec_create(&vec, 8)) {\n        printf("created a vector\\n\\n");\n        vec_fill_sequential(vec);\n        dump_vec(vec);\n\n        /*\n            Single free releases both header and payload because data[]\n            is a C99 flexible array member appended to the header.\n        */\n        free(vec);\n    } else {\n        fprintf(stderr, "failed to create vector\\n");\n        return 1;\n    }\n\n    return 0;\n}\n\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern C99 Techniques You Can Use Today")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"1) Brace initialization")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int x = { 42 };\nstruct Point { int x, y; };\nstruct Point p = { .x = 10, .y = 20 };\nint a[] = { 1, 2, 3 };\nint b[5] = { 1 };\n")),(0,i.kt)("p",null,"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"{}")," initializers for scalars, arrays, and structs. Unlisted members become zero. ",(0,i.kt)("inlineCode",{parentName:"p"},"{0}")," ensures explicit zeroing. For scalars, ",(0,i.kt)("inlineCode",{parentName:"p"},"int x = { 42 };")," is the same as ",(0,i.kt)("inlineCode",{parentName:"p"},"int x = 42;"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"2) Zeroing with ",(0,i.kt)("inlineCode",{parentName:"strong"},"{0}"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct State s = { 0 };\nint zeros[16] = { 0 };\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"{0}")," zeroes the first element and, by rule, all others. ",(0,i.kt)("inlineCode",{parentName:"p"},"{}")," is a C23 feature, not C99."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"3) Designated initializers")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct Cfg { int id, flags, mode, status; };\nstruct Cfg c1 = { .id = 7, .status = 2 };\n")),(0,i.kt)("p",null,"Mix positional and named initializers. Later values override earlier ones. Safer against field reorder."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"4) Array element designators")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int fib[] = {\n    [0] = 0, [1] = 1, [2] = 1,\n    [10] = 55, 89\n};\n")),(0,i.kt)("p",null,"Sparse initialization. Size deduced as highest index + 1. Missing entries zeroed."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"5) Nested designators")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct Item { int k; struct { int lo, hi; } ext; };\nstruct Item table[] = {\n    [0]  = { .k = 1, .ext = { .lo = -3, .hi = 3 } },\n    [10] = { .ext.hi = 99 }\n};\n")),(0,i.kt)("p",null,"Set deep fields directly. Useful for lookup tables."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"6) Variable Length Arrays (VLAs) in parameters")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"void fill(int n, int buf[n]);\nvoid sum_n(size_t n, double buf[static 3]);\n")),(0,i.kt)("p",null,"In parameters, VLAs encode bounds and non-null contracts. Avoid large VLAs as locals, they can exhaust the stack."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"7) Pointer contracts with ",(0,i.kt)("inlineCode",{parentName:"strong"},"static 1"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"void print_line(const char *static 1 s);\n")),(0,i.kt)("p",null,"Means non-null pointer to at least one element. Passing NULL is UB. Only use when required."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"8) Strongly typed 2D arrays")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"size_t n = 5, m = 7;\ndouble (*mat)[m] = malloc(sizeof *mat * n);\nmat[2][3] = 1.0;\n")),(0,i.kt)("p",null,"Keeps row/column math correct. One allocation, one free."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"9) ",(0,i.kt)("inlineCode",{parentName:"strong"},"sizeof")," with VLA types")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int (*grid)[m] = malloc(sizeof *grid * n);\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"sizeof *grid")," always equals ",(0,i.kt)("inlineCode",{parentName:"p"},"m * sizeof(int)"),". Safer against refactor mistakes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"10) Compound literals")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"v = (struct Vec){ .cap = 64, .len = 0, .data = calloc(64, sizeof *v.data) };\ntime_t t = mktime(&(struct tm){ .tm_year = 124, .tm_mon = 8, .tm_mday = 28 });\n")),(0,i.kt)("p",null,"Temporary lvalues. Use ",(0,i.kt)("inlineCode",{parentName:"p"},"(Type){0}")," to clear. Block-scope literals live until block ends."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"11) Named-argument style calls")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#define BLUR(...) blur(&(struct BlurParams){ __VA_ARGS__ })\nBLUR(.dst = dst, .src = src, .width = w, .height = h, .kernel = 5);\n")),(0,i.kt)("p",null,"Makes call sites self-documenting. Do not store the address of these temporaries."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"12) Default values with overlay macros")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#define BLUR_DEFAULTS .compute_hw = 0, .kernel = 3\n#define BLUR2(...) blur(&(struct BlurParams){ BLUR_DEFAULTS, __VA_ARGS__ })\n")),(0,i.kt)("p",null,"Later fields override earlier ones. Keep defaults consistent with struct definition."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"13) Flexible array members")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct Str { size_t len; char data[]; };\nstruct Str *s = malloc(sizeof *s + n + 1);\n")),(0,i.kt)("p",null,"Header and payload in one block. Better locality, single free. FAM must be last, and has no declared size."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"14) Single malloc vector")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct Vector { size_t capacity, size; double data[]; };\n*v = (struct Vector){ .capacity = capacity, .size = 0 };\n")),(0,i.kt)("p",null,"Use FAM to pack header and elements into one allocation."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"15) Macro overloading by arg count")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#define _GET_3RD(a,b,c,...) c\n#define _SELECT_SCALE(...) _GET_3RD(__VA_ARGS__, scale_rect2, scale_rect1)\n#define scale_rect_auto(r, ...) _SELECT_SCALE(__VA_ARGS__)(r, __VA_ARGS__)\n")),(0,i.kt)("p",null,"Simulates overloading. Pure preprocessor trick, no type checking."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Portability and safety")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use ",(0,i.kt)("inlineCode",{parentName:"li"},"<stdbool.h>")," for ",(0,i.kt)("inlineCode",{parentName:"li"},"bool"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"true"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"false"),"."),(0,i.kt)("li",{parentName:"ul"},"VLAs are required in C99 but optional in later standards. Some compilers disable them."),(0,i.kt)("li",{parentName:"ul"},"Contracts with ",(0,i.kt)("inlineCode",{parentName:"li"},"static k")," are promises, not checks. Violating them is UB."),(0,i.kt)("li",{parentName:"ul"},"Flexible array members require careful allocation.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Safer alternatives")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Prefer heap + VLA types for large arrays."),(0,i.kt)("li",{parentName:"ul"},"Use ",(0,i.kt)("inlineCode",{parentName:"li"},"(Type){0}")," to clear objects, not ",(0,i.kt)("inlineCode",{parentName:"li"},"memset"),"."),(0,i.kt)("li",{parentName:"ul"},"Use designated initializers for public config structs."),(0,i.kt)("li",{parentName:"ul"},"Use macro overlays for defaults.")),(0,i.kt)("p",null,"2025-07-13 ",(0,i.kt)("a",{parentName:"p",href:"https://www.lelanthran.com/chap13/content.html"},"Parse, Don\u2019t Validate AKA Some C Safety Tips")," { ",(0,i.kt)("a",{parentName:"p",href:"http://www.lelanthran.com"},"www.lelanthran.com")," }"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'The article "Parse, Don\u2019t Validate AKA Some C Safety Tips" by Lelanthran expands on the concept of converting input into strong types rather than merely validating it as plain strings. It demonstrates how this approach, when applied in C, reduces error-prone code and security risks. The post outlines three practical benefits: boundary handling with opaque types, safer memory cleanup via pointer\u2011setting destructors, and compile\u2011time type safety that prevents misuse deeper in the codebase.'),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Key Takeaways:")),(0,i.kt)("ol",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Use Strong, Opaque Types for Input"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Instead of handling raw ",(0,i.kt)("inlineCode",{parentName:"li"},"char *"),", parse untrusted input into dedicated types like ",(0,i.kt)("inlineCode",{parentName:"li"},"email_t")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"name_t"),"."),(0,i.kt)("li",{parentName:"ul"},"This restricts raw input to the system boundary and ensures all later code works with validated, structured data."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Reduce Attack Surface"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Only boundary functions see untrusted strings; internal functions operate on safe, strongly typed data."),(0,i.kt)("li",{parentName:"ul"},"This prevents deeper code from encountering malformed or malicious input."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Enforce Correctness at Compile Time"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"With distinct types, the compiler prohibits misuse, such as passing an ",(0,i.kt)("inlineCode",{parentName:"li"},"email_t*")," to a function expecting a ",(0,i.kt)("inlineCode",{parentName:"li"},"name_t*"),"."),(0,i.kt)("li",{parentName:"ul"},"What would be a runtime bug becomes a compiler error."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Implement Defensive Destructors"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"Design destructor functions to take a double pointer (",(0,i.kt)("inlineCode",{parentName:"li"},"T **"),") so they can free and then set the pointer to ",(0,i.kt)("inlineCode",{parentName:"li"},"NULL"),"."),(0,i.kt)("li",{parentName:"ul"},"This prevents double\u2011free errors and related memory safety issues."))),(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("strong",{parentName:"li"},"Eliminate Internal String Handling"),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},"By centralizing parsing near the system entry and eliminating ",(0,i.kt)("inlineCode",{parentName:"li"},"char *")," downstream, code becomes safer and clearer."),(0,i.kt)("li",{parentName:"ul"},"Once input is parsed, the rest of the system works with well-typed data only.")))),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20250713115328366",src:a(73017).Z,width:"953",height:"872"}))),(0,i.kt)("h2",{id:"c99-reimplement-this-world"},"C99 Reimplement this world!"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"\ud83d\udca1 C99 keeps the standard library small, so engineers often reimplement common utilities -- strings, containers, parsing, algorithms. That repetition is a feature: it produces many competing designs you can read, compare, and learn a lot from because different approaches expose trade-offs and techniques.")),(0,i.kt)("p",null,"2025-10-03 ",(0,i.kt)("a",{parentName:"p",href:"https://attractivechaos.github.io/klib/#About"},"Klib \u2014 a generic library in C")," { attractivechaos.github.io }"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("a",{parentName:"p",href:"https://github.com/attractivechaos/klib"},"attractivechaos/klib: A standalone and lightweight C library")," { github.com }"),(0,i.kt)("p",{parentName:"blockquote"},"Klib shows how to build fast, low-overhead \u201cstandard library\u201d pieces in plain C without templates or ",(0,i.kt)("inlineCode",{parentName:"p"},"void*")," indirection. The core pattern is macro-based generics: you instantiate a container or algorithm with a type name macro, and the preprocessor generates type-specialized code. That keeps binaries small, avoids runtime casts, and stays competitive with handwritten, type-specific containers. The README and docs stress this trade-off explicitly and show the macro expansion style with ",(0,i.kt)("inlineCode",{parentName:"p"},"khash.h")," as the teaching example."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20251003112834630",src:a(42592).Z,width:"1000",height:"620"})),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("strong",{parentName:"p"},"Common components")),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"[khash.h]","(",(0,i.kt)("a",{parentName:"li",href:"https://attractivechaos.github.io/klib/#Khash%3A"},"https://attractivechaos.github.io/klib/#Khash%3A")," generic hash table): generic hash table based on double hashing."),(0,i.kt)("li",{parentName:"ul"},"[kbtree.h]","(",(0,i.kt)("a",{parentName:"li",href:"https://attractivechaos.github.io/klib/#KBtree%3A"},"https://attractivechaos.github.io/klib/#KBtree%3A")," generic ordered map): generic search tree based on B-tree."),(0,i.kt)("li",{parentName:"ul"},"[kavl.h]","(",(0,i.kt)("a",{parentName:"li",href:"https://attractivechaos.github.io/klib/#KAVL%3A"},"https://attractivechaos.github.io/klib/#KAVL%3A")," generic intrusive AVL tree): generic intrusive AVL tree."),(0,i.kt)("li",{parentName:"ul"},"[ksort.h]","(",(0,i.kt)("a",{parentName:"li",href:"https://attractivechaos.github.io/klib/#Ksort%3A"},"https://attractivechaos.github.io/klib/#Ksort%3A")," sorting%2C shuffling%2C heap and k-small): generic sort, including introsort, merge sort, heap sort, comb sort, Knuth shuffle and the k-small algorithm."),(0,i.kt)("li",{parentName:"ul"},"[kseq.h]","(",(0,i.kt)("a",{parentName:"li",href:"https://attractivechaos.github.io/klib/#Kseq%3A"},"https://attractivechaos.github.io/klib/#Kseq%3A")," stream buffer and FASTA%2FQ parser): generic stream buffer and a FASTA/FASTQ format parser."),(0,i.kt)("li",{parentName:"ul"},"kvec.h: generic dynamic array."),(0,i.kt)("li",{parentName:"ul"},"[kdq.h]","(",(0,i.kt)("a",{parentName:"li",href:"https://attractivechaos.github.io/klib/#Kdq%3A"},"https://attractivechaos.github.io/klib/#Kdq%3A")," double-ended queue): generic double-ended queue (de-queue)."),(0,i.kt)("li",{parentName:"ul"},"klist.h: generic single-linked list and memory pool."),(0,i.kt)("li",{parentName:"ul"},"kstring.{h,c}: basic string library."),(0,i.kt)("li",{parentName:"ul"},"[ketopt.h]","(",(0,i.kt)("a",{parentName:"li",href:"https://attractivechaos.github.io/klib/#Ketopt%3A"},"https://attractivechaos.github.io/klib/#Ketopt%3A")," parsing command-line arguments): command-line argument parser, similar to ",(0,i.kt)("a",{parentName:"li",href:"https://linux.die.net/man/3/getopt_long"},"getopt_long"),"."),(0,i.kt)("li",{parentName:"ul"},"kmath.{h,c}: numerical routines including basic nonlinear programming and a few special math functions."),(0,i.kt)("li",{parentName:"ul"},"[kson.{h,c}]","(",(0,i.kt)("a",{parentName:"li",href:"https://attractivechaos.github.io/klib/#Kson%3A"},"https://attractivechaos.github.io/klib/#Kson%3A")," simple JSON parser): simple ",(0,i.kt)("a",{parentName:"li",href:"http://www.json.org/"},"JSON")," parser (no streaming)"),(0,i.kt)("li",{parentName:"ul"},"[kthread.{h,c}]","(",(0,i.kt)("a",{parentName:"li",href:"https://attractivechaos.github.io/klib/#Kthread%3A"},"https://attractivechaos.github.io/klib/#Kthread%3A")," simple threading models): simple multi-threading models."))),(0,i.kt)("p",null,"Samples:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Hash map: int -> char\n#include \"khash.h\"\nKHASH_MAP_INIT_INT(m32, char)\nint main() {\n  int absent; khint_t k;\n  khash_t(m32)* h = kh_init(m32);\n  k = kh_put(m32, h, 42, &absent);\n  if (absent) kh_value(h, k) = 'x';\n  k = kh_get(m32, h, 42);\n  if (k != kh_end(h)) kh_del(m32, h, k);\n  kh_destroy(m32, h);\n}\n")),(0,i.kt)("p",null,"2025-10-03 ",(0,i.kt)("a",{parentName:"p",href:"https://drh.github.io/cii/toc.html"},"C Interfaces and Implementations")," { drh.github.io }"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("a",{parentName:"p",href:"https://github.com/drh/cii"},"drh/cii: C Interfaces and Implementations")," { github.com }"),(0,i.kt)("p",{parentName:"blockquote"},"David R. Hanson\u2019s C Interfaces and Implementations (CII) is both a textbook and a production-grade library. The repository contains the complete source for the book\u2019s 24 interfaces and implementations. The code favors clarity and pedagogical structure over clever micro-optimizations. It\u2019s rich with reusable idioms: strict interface/implementation separation, minimal public surface area, explicit memory-management modules, compact yet complete data-structure implementations, and a small set of concurrency primitives with hand-written context switching."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20251003113819314",src:a(1240).Z,width:"1168",height:"761"}))),(0,i.kt)("h2",{id:"dev-c-articles"},"Dev C Articles"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"2022-03-05 ",(0,i.kt)("a",{parentName:"li",href:"https://www.lurklurk.org/linkers/linkers.html"},"Beginner's Guide to Linkers"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"This article is intended to help C & C++ programmers understand the essentials of what the linker does. I've explained this to a number of colleagues over the years, so I decided it was time to write it down so that it's more widely available.")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"2022-11-28 ",(0,i.kt)("a",{parentName:"li",href:"https://tmewett.com/c-tips/"},"Everything I wish I knew when learning C - Tom M"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Learning C was quite difficult for me. The basics of the language itself weren\u2019t so bad, but \u201cprogramming in C\u201d requires a lot of other kinds of knowledge which aren\u2019t as easy to pick up on:"),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},"C has no environment which smooths out platform or OS differences; you need to know about your platform too"),(0,i.kt)("li",{parentName:"ul"},"there are many C compiler options and build tools, making even running a simple program involve lots of decisions"),(0,i.kt)("li",{parentName:"ul"},"there are important concepts related to CPUs, OSes, compiled code in general"),(0,i.kt)("li",{parentName:"ul"},"it\u2019s used in such varied ways that there\u2019s far less a centralised \u201ccommunity\u201d or style than other languages"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"2022-11-13 Building a simple shell in C"),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"A basic shell that prints a prompt, waits for user to enter command and prints what they entered on the next line")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.ehoneahobed.com/building-a-simple-shell-in-c-part-1"},"Building a simple shell in C - Part 1")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.ehoneahobed.com/building-a-simple-shell-in-c-part-2"},"Building a simple shell in C - Part 2")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://blog.ehoneahobed.com/building-a-simple-shell-in-c-part-3"},"Building a simple shell in C - Part 3")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"2022-11-13 ",(0,i.kt)("a",{parentName:"p",href:"https://viewsourcecode.org/snaptoken/kilo/"},"Build Your Own Text Editor")),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"Welcome! This is an instruction booklet that shows you how to build a text editor in C."),(0,i.kt)("p",{parentName:"blockquote"},"The text editor is antirez\u2019s kilo, with some changes. It\u2019s about 1000 lines of C in a single file with no dependencies, and it implements all the basic features you expect in a minimal editor, as well as syntax highlighting and a search feature."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"2023-05-22 ",(0,i.kt)("a",{parentName:"p",href:"https://samwho.dev/memory-allocation/"},"Memory Allocation")))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"One thing that all programs on your computer have in common is a need for memory. Programs need to be loaded from your hard drive into memory before they can be run. While running, the majority of what programs do is load values from memory, do some computation on them, and then store the result back in memory."),(0,i.kt)("p",{parentName:"blockquote"},"In this post I'm going to introduce you to the basics of memory allocation. Allocators exist because it's not enough to have memory available, you need to use it effectively. We will visually explore how simple allocators work. We'll see some of the problems that they try to solve, and some of the techniques used to solve them. At the end of this post, you should know everything you need to know to write your own allocator."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20230528170203659",src:a(75178).Z,width:"853",height:"548"}))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"2023-07-01 ",(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c"},"Few lesser known tricks, quirks and features of C"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"There are some tricks, quirks and features (some quite fundamental to the language!) which seems to throw even experienced developers off the track. Thus I did a sloppy job of gathering some of them in this post (in no particular order) with even sloppier short explanations and/or examples (or quote of thereof)."),(0,i.kt)("ul",{parentName:"blockquote"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#array-pointers"},"Array pointers")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#comma-operator"},"Comma operator")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#digraphs-trigraphs-and-alternative-tokens"},"Digraphs, trigraphs and alternative tokens")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#designated-initializer"},"Designated initializer")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#compound-literals"},"Compound literals")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#compound-literals-are-lvalues"},"Compound literals are lvalues")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#multi-character-constants"},"Multi-character constants")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#bit-fields"},"Bit fields")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#0-bit-fields"},"0 bit fields")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#volatile-type-qualifier"},(0,i.kt)("inlineCode",{parentName:"a"},"volatile")," type qualifier")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#restrict-type-qualifier"},(0,i.kt)("inlineCode",{parentName:"a"},"restrict")," type qualifier")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#register-type-qualifier"},(0,i.kt)("inlineCode",{parentName:"a"},"register")," type qualifier")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#flexible-array-member"},"Flexible array member")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#n-format-specifier"},(0,i.kt)("inlineCode",{parentName:"a"},"%n")," format specifier")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#-minimum-field-width-format-specifier"},(0,i.kt)("inlineCode",{parentName:"a"},"%.*")," (minimum field width) format specifier")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#other-less-known-format-specifiers"},"Other less known format specifiers")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#interlacing-syntactic-constructs"},"Interlacing syntactic constructs")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#---operator"},(0,i.kt)("inlineCode",{parentName:"a"},"--\x3e"),' "operator"')),(0,i.kt)("li",{parentName:"ul"},"[",(0,i.kt)("inlineCode",{parentName:"li"},"idx[arr\\]"),"](",(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#idxarr"},"https://jorengarenar.github.io/blog/less-known-c#idxarr"),")"),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#negative-array-indexes"},"Negative array indexes")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#constant-string-concatenation"},"Constant string concatenation")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#backslash-line-splicing"},"Backslash line splicing")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#using--and--as-conditionals"},"Using ",(0,i.kt)("inlineCode",{parentName:"a"},"&&")," and ",(0,i.kt)("inlineCode",{parentName:"a"},"||")," as conditionals")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#compile-time-assumption-checking-using-enums"},"Compile time assumption checking using ",(0,i.kt)("inlineCode",{parentName:"a"},"enum"),"s")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#ad-hoc-struct-declaration-in-the-return-type-of-a-function"},"Ad hoc ",(0,i.kt)("inlineCode",{parentName:"a"},"struct")," declaration in the return type of a function")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#nested-struct-definition-is-not-kept-nested"},'"Nested" ',(0,i.kt)("inlineCode",{parentName:"a"},"struct")," definition is not kept nested")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#flat-initializer-lists"},"Flat initializer lists")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#implicit-casting-of-void-pointers"},"Implicit casting of ",(0,i.kt)("inlineCode",{parentName:"a"},"void")," pointers")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#static-array-indices-in-function-parameter-declarations"},"Static array indices in function parameter declarations")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#macro-overloading-by-argument-list-length"},"Macro Overloading by Argument List Length")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#function-types"},"Function types")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#x-macros"},"X-Macros")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#named-function-parameters"},"Named function parameters")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#combining-default-named-and-positional-arguments"},"Combining default, named and positional arguments")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#abusing-unions-for-grouping-things-into-namespaces"},"Abusing unions for grouping things into namespaces")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#unity-builds"},"Unity builds")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#matching-character-classes-with-sscanf"},"Matching character classes with ",(0,i.kt)("inlineCode",{parentName:"a"},"sscanf()"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#garbage-collector"},"Garbage collector")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#cosmopolitan-libc"},"Cosmopolitan Libc")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#inline-assembly"},"Inline assembly")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#object-oriented-programming"},"Object Oriented Programming")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#metaprogramming"},"Metaprogramming")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("a",{parentName:"li",href:"https://jorengarenar.github.io/blog/less-known-c#evaluate-sizeof-at-compile-time-by-causing-duplicate-case-error"},"Evaluate ",(0,i.kt)("inlineCode",{parentName:"a"},"sizeof")," at compile time by causing duplicate case error")))),(0,i.kt)("p",null,"2023-06-30 ",(0,i.kt)("a",{parentName:"p",href:"https://abstractexpr.com/2023/06/29/structures-in-c-from-basics-to-memory-alignment/"},"Structures in C: From Basics to Memory Alignment \u2013 Abstract Expression")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Structures allow us to combine several variables to create a new data type. Some other languages support the same concept but call it \u201crecords\u201d. If you come from object-oriented programming you can think about them as classes without methods."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20230702152138229",src:a(57629).Z,width:"740",height:"886"}))),(0,i.kt)("h2",{id:"books"},"Books"),(0,i.kt)("p",null,"1993 \u2b50 ",(0,i.kt)("a",{parentName:"p",href:"https://www.mclibre.org/descargar/docs/libros/ooc-ats.pdf"},"Object-oriented Programming with ANSI-C (1993) [pdf]")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Retro document! but very well written"),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20230629003429585",src:a(36095).Z,width:"969",height:"577"}))),(0,i.kt)("h2",{id:"rss"},"RSS"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"TODO List to review later")),(0,i.kt)("p",null,"2025-10-03 ",(0,i.kt)("a",{parentName:"p",href:"https://nullprogram.com/blog/2018/07/31/"},"Prospecting for Hash Functions")," { nullprogram.com }"),(0,i.kt)("h2",{id:"dev-c-tools"},"Dev C Tools"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"2022-03-07 ",(0,i.kt)("a",{parentName:"li",href:"https://github.com/clibs/clib"},"clibs/clib: C package manager-ish"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Package manager for the C programming language.")),(0,i.kt)("h2",{id:"dev-c-libs"},"Dev C Libs"),(0,i.kt)("h3",{id:"net"},"Net"),(0,i.kt)("p",null,"2023-05-17 ",(0,i.kt)("a",{parentName:"p",href:"https://www.dpdk.org/"},"Home - DPDK")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"2023-05-17 ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/DPDK/dpdk"},"DPDK/dpdk: Data Plane Development Kit")),(0,i.kt)("p",{parentName:"blockquote"},"DPDK (Data Plane Development Kit) is an open-source software project that provides a set of libraries and drivers for fast packet processing in user space. Its main goal is to increase the performance of packet processing applications running on standard computing platforms. The project is hosted and can be accessed at ",(0,i.kt)("a",{parentName:"p",href:"http://www.dpdk.org/"},"www.dpdk.org"),". It's widely used in network interface cards, routers, firewalls, and other networking appliances.")),(0,i.kt)("h3",{id:"c-language-development"},"C language development"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"2022-03-05 ",(0,i.kt)("a",{parentName:"li",href:"https://libcello.org/"},"Cello \u2022 High Level C"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Cello is a library that brings higher level programming to C.\nNew C syntax for New Era!")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#include "Cello.h"\n\nint main(int argc, char** argv) {\n\n  /* Stack objects are created using "$" */\n  var i0 = $(Int, 5);\n  var i1 = $(Int, 3);\n  var i2 = $(Int, 4);\n\n  /* Heap objects are created using "new" */\n  var items = new(Array, Int, i0, i1, i2);\n\n  /* Collections can be looped over */\n  foreach (item in items) {\n    print("Object %$ is of type %$\\n",\n      item, type_of(item));\n  }\n\n  /* Heap objects destructed via Garbage Collection */\n  return 0;\n}\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"2022-03-16 ",(0,i.kt)("a",{parentName:"li",href:"http://libmill.org/index.html"},"libmill")," Libmill is a library that introduces Go-style concurrency to C")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"go(foo(arg1, arg2, arg3));\nchan ch = chmake(int, 0);\nchan ch = chmake(int, 1000);\nchs(ch, int, 42);\n")),(0,i.kt)("h3",{id:"simd"},"SIMD"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"2022-05-01 ",(0,i.kt)("inlineCode",{parentName:"li"},"simd")," ",(0,i.kt)("a",{parentName:"li",href:"https://lemire.me/blog/2022/04/28/removing-characters-from-strings-faster-with-avx-512/"},"Removing characters from strings faster with AVX-512 \u2013 Daniel Lemire's blog"))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"A computer science professor at the University of Quebec (TELUQ). View all posts by Daniel Lemire")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("a",{parentName:"p",href:"https://github.com/DragonSpit/HPCsharp"},"DragonSpit/HPCsharp: High performance algorithms in C#: SIMD/SSE, multi-core and faster"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"(2021-09-26) ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/google/highway"},"google/highway: Performance-portable, length-agnostic SIMD with runtime dispatch"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"(2021-12-26) ",(0,i.kt)("a",{parentName:"p",href:"https://blog.tinybird.co/2021/12/14/simd/"},"Splitting CSV files at 3GB/s \xb7 Tinybird")," with SIMD! Good C lang examples on this topic.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"2023-06-02 ",(0,i.kt)("a",{parentName:"p",href:"https://cvw.cac.cornell.edu/vector/overview_simd"},"Cornell Virtual Workshop: SIMD Parallelism")))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},'SIMD stands for "Single Instruction Multiple Data," and is one of ',(0,i.kt)("a",{parentName:"p",href:"https://cvw.cac.cornell.edu/parallel/tax.aspx"},"several approaches to parallelism")," found in modern high-performance computing."),(0,i.kt)("p",{parentName:"blockquote"},"Vector instructions are a primary example of SIMD parallelism in modern CPUs. For instance, the vector add instruction is a single instruction (add) that acts on multiple data (vectors) to yield a vector of sums. Given the two vectors ",(0,i.kt)("inlineCode",{parentName:"p"},"(1, 2, 3, 4)")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"(5, 6, 7, 8)"),", the vector result ",(0,i.kt)("inlineCode",{parentName:"p"},"(6, 8, 10, 12)")," is produced in a single operation. This operation is illustrated in the diagram and linked video below.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20230608160855199",src:a(50353).Z,width:"1243",height:"1053"}))),(0,i.kt)("p",null,"2023-07-02 ",(0,i.kt)("a",{parentName:"p",href:"https://lemire.me/blog/2023/07/01/parsing-time-stamps-faster-with-simd-instructions/"},"Parsing time stamps faster with SIMD instructions \u2013 Daniel Lemire's blog")),(0,i.kt)("p",null,"Standard:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#include <time.h>\n#include <stdio.h>\nint main() {\n  char buffer[15];\n  struct tm timeinfo;\n  time_t rawtime;\n  time(&rawtime);\n  gmtime_r(&rawtime, &timeinfo);\n  size_t len = strftime(buffer, 15, \"%Y%m%d%H%M%S\", &timeinfo);\n  buffer[14] = '\\0';\n  puts(buffer);\n}\n")),(0,i.kt)("p",null,"SIMD:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"}," __m128i v = _mm_loadu_si128((const __m128i *)date_string);\nv = _mm_sub_epi8(v, _mm_set1_epi8(0x30));\n__m128i limit =\n_mm_setr_epi8(9, 9, 9, 9, 1, 9, 3, 9, 2, 9, 5, 9, 5, 9, -1, -1);\n__m128i abide_by_limits = _mm_subs_epu8(v, limit); // must be all zero\nconst __m128i weights = _mm_setr_epi8(\n10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 10, 1, 0, 0);\nv = _mm_maddubs_epi16(v, weights);\n__m128i limit16 =\n_mm_setr_epi16(99,99, 12, 31, 23, 59, 59, -1);\n__m128i abide_by_limits16 = _mm_subs_epu16(v, limit16);\n__m128i limits = _mm_or_si128(abide_by_limits16,abide_by_limits);\nif (!_mm_test_all_zeros(limits, limits)) {\n  return false;\n}\n")),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:"left"},"instructions per stamp"),(0,i.kt)("th",{parentName:"tr",align:"left"},"time per stamp"),(0,i.kt)("th",{parentName:"tr",align:null}))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"standard C with ",(0,i.kt)("inlineCode",{parentName:"td"},"strptime")),(0,i.kt)("td",{parentName:"tr",align:"left"},"700"),(0,i.kt)("td",{parentName:"tr",align:null},"46")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:"left"},"SIMD approach"),(0,i.kt)("td",{parentName:"tr",align:"left"},"65"),(0,i.kt)("td",{parentName:"tr",align:null},"7.9")))))}u.isMDXComponent=!0},75178:function(e,t,a){t.Z=a.p+"assets/images/image-20230528170203659-204155b73aa27ea7e8bec8efc6e5f671.png"},50353:function(e,t,a){t.Z=a.p+"assets/images/image-20230608160855199-ccb0328a737c5ff4cb9f77dcb1aa4c73.png"},36095:function(e,t,a){t.Z=a.p+"assets/images/image-20230629003429585-2397577d9e53da9f1098b2887db0cfa3.png"},57629:function(e,t,a){t.Z=a.p+"assets/images/image-20230702152138229-4c0d566a6507de2efd85cd8dd9982a0b.png"},73017:function(e,t,a){t.Z=a.p+"assets/images/image-20250713115328366-f0616739ea1fdb401dad0f0ac285ccf0.png"},35565:function(e,t,a){t.Z=a.p+"assets/images/image-20250801102620753-4ade58a55cf7141941b8238f94c49bfe.png"},48322:function(e,t,a){t.Z=a.p+"assets/images/image-20250801103430609-b2abb6b0bd26725d6b8d4cb22ece4fb0.png"},71480:function(e,t,a){t.Z=a.p+"assets/images/image-20250801230639700-85d707df773bf19104e92643156bdd7c.png"},90482:function(e,t,a){t.Z=a.p+"assets/images/image-20250801230857693-daf23da57a4b2685128f89b1e0cc4041.png"},2462:function(e,t,a){t.Z=a.p+"assets/images/image-20250801233701958-d6423be448a620e992c10ce1cdaafae0.png"},97917:function(e,t,a){t.Z=a.p+"assets/images/image-20250802105718241-a3f21bc10dc5867298837f7bff88c643.png"},40014:function(e,t,a){t.Z=a.p+"assets/images/image-20250928150824455-81d64f12e73b9510dc045f0012f95ac9.png"},42592:function(e,t,a){t.Z=a.p+"assets/images/image-20251003112834630-fca1ad95f831362069b9a5b53cda41ff.png"},1240:function(e,t,a){t.Z=a.p+"assets/images/image-20251003113819314-d5758ac68ea32f5c41db8f8ec9d51eb4.png"}}]);