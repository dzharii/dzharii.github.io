"use strict";(self.webpackChunkzharii=self.webpackChunkzharii||[]).push([[9964],{3905:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return u}});var a=t(67294);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function o(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=a.createContext({}),c=function(e){var n=a.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):o(o({},n),e)),t},d=function(e){var n=c(e.components);return a.createElement(l.Provider,{value:n},e.children)},p={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},m=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),m=c(t),u=r,g=m["".concat(l,".").concat(u)]||m[u]||p[u]||i;return t?a.createElement(g,o(o({ref:n},d),{},{components:t})):a.createElement(g,o({ref:n},d))}));function u(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,o=new Array(i);o[0]=m;var s={};for(var l in n)hasOwnProperty.call(n,l)&&(s[l]=n[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,o[1]=s;for(var c=2;c<i;c++)o[c]=t[c];return a.createElement.apply(null,o)}return a.createElement.apply(null,t)}m.displayName="MDXCreateElement"},88291:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return l},metadata:function(){return c},assets:function(){return d},toc:function(){return p},default:function(){return u}});var a=t(87462),r=t(63366),i=(t(67294),t(3905)),o=["components"],s={layout:"post",title:"Links from my inbox 2024-09-01",date:new Date("2024-09-01T21:58:00.000Z"),categories:"links"},l=void 0,c={permalink:"/blog/2024/09/01/links-from-my-inbox",editUrl:"https://github.com/dzharii/dzharii.github.io/blog/2024-09-01-links-from-my-inbox.md",source:"@site/blog/2024-09-01-links-from-my-inbox.md",title:"Links from my inbox 2024-09-01",description:"The Talk",date:"2024-09-01T21:58:00.000Z",formattedDate:"September 1, 2024",tags:[],readingTime:14.08,truncated:!1,authors:[],frontMatter:{layout:"post",title:"Links from my inbox 2024-09-01",date:"2024-09-01T21:58:00.000Z",categories:"links"},prevItem:{title:"Links from my inbox 2024-09-15",permalink:"/blog/2024/09/15/links-from-my-inbox"},nextItem:{title:"Links from my inbox 2024-08-30",permalink:"/blog/2024/08/30/links-from-my-inbox"}},d={authorsImageUrls:[]},p=[{value:"The Talk",id:"the-talk",children:[],level:2},{value:"GPT generated content (close to the talk content)",id:"gpt-generated-content-close-to-the-talk-content",children:[{value:"1. <strong>SFINAE and Overload Resolution</strong>",id:"1-sfinae-and-overload-resolution",children:[],level:3},{value:"2. <strong>Compile-Time Error Messages</strong>",id:"2-compile-time-error-messages",children:[],level:3},{value:"3. <strong>Concepts in C++20</strong>",id:"3-concepts-in-c20",children:[],level:3},{value:"4. <strong>Polymorphism and CRTP</strong>",id:"4-polymorphism-and-crtp",children:[],level:3},{value:"5. <strong>Deducing <code>this</code> in C++23</strong>",id:"5-deducing-this-in-c23",children:[],level:3},{value:"6. <strong>Design Methodologies: Procedural, OOP, Functional, and Data-Oriented Design</strong>",id:"6-design-methodologies-procedural-oop-functional-and-data-oriented-design",children:[],level:3}],level:2},{value:"GPT generated content (with a bit of &quot;hallucinations&quot;)",id:"gpt-generated-content-with-a-bit-of-hallucinations",children:[],level:2}],m={toc:p};function u(e){var n=e.components,s=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},m,s,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h2",{id:"the-talk"},"The Talk"),(0,i.kt)("p",null,"2024-09-01 ",(0,i.kt)("a",{parentName:"p",href:"https://www.youtube.com/watch?v=DvM8oKA1YiM"},"Investigating Legacy Design Trends in C++ & Their Modern Replacements - Katherine Rocha C++Now 2024 - YouTube")," { ",(0,i.kt)("a",{parentName:"p",href:"http://www.youtube.com"},"www.youtube.com")," }"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Katherine Rocha")),(0,i.kt)("p",null,(0,i.kt)("img",{alt:"image-20240901150003068",src:t(88099).Z,width:"1099",height:"506"})),(0,i.kt)("h2",{id:"gpt-generated-content-close-to-the-talk-content"},"GPT generated content (close to the talk content)"),(0,i.kt)("p",null,"This digest is a comprehensive breakdown of the talk provided, which covered various advanced C++ programming techniques and concepts. Below, each point from the talk is identified and described in detail, followed by relevant C++ code examples to illustrate the discussed concepts."),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"1-sfinae-and-overload-resolution"},"1. ",(0,i.kt)("strong",{parentName:"h3"},"SFINAE and Overload Resolution")),(0,i.kt)("p",null,"The talk begins with a discussion on the use of ",(0,i.kt)("strong",{parentName:"p"},"SFINAE")," (Substitution Failure Is Not An Error) and its role in ",(0,i.kt)("strong",{parentName:"p"},"overload resolution"),". SFINAE is a powerful C++ feature that allows template functions to be excluded from overload resolution based on specific conditions, enabling more precise control over which function templates should be used."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Points"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"SFINAE")," is used to selectively disable template instantiation based on the properties of template arguments."),(0,i.kt)("li",{parentName:"ul"},"Overload resolution in C++ allows for multiple functions or operators with the same name to be defined, as long as their parameters differ. The compiler decides which function to call based on the arguments provided.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"C++ Example"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <type_traits>\n#include <iostream>\n\n// Template function enabled only for arithmetic types using SFINAE\ntemplate <typename T>\ntypename std::enable_if<std::is_arithmetic<T>::value, T>::type\nadd(T a, T b) {\n    return a + b;\n}\n\n// Overload for non-arithmetic types is not instantiated\ntemplate <typename T>\ntypename std::enable_if<!std::is_arithmetic<T>::value, T>::type\nadd(T a, T b) = delete;\n\nint main() {\n    std::cout << add(5, 3) << std::endl;     // OK: int is arithmetic\n    // std::cout << add("Hello", "World");   // Error: string is not arithmetic\n    return 0;\n}\n')),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"2-compile-time-error-messages"},"2. ",(0,i.kt)("strong",{parentName:"h3"},"Compile-Time Error Messages")),(0,i.kt)("p",null,"The talk transitions into how to improve ",(0,i.kt)("strong",{parentName:"p"},"compile-time error messages")," using ",(0,i.kt)("inlineCode",{parentName:"p"},"static_assert")," and custom error handling in templates. By using these techniques, developers can provide clearer error messages when certain conditions are not met during template instantiation."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Points"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Use ",(0,i.kt)("inlineCode",{parentName:"li"},"static_assert")," to enforce conditions at compile time, ensuring that the program fails to compile if certain criteria are not met."),(0,i.kt)("li",{parentName:"ul"},"Improve the readability of error messages by providing meaningful feedback directly in the code.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"C++ Example"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <type_traits>\n\ntemplate<typename T>\nvoid check_type() {\n    static_assert(std::is_integral<T>::value, "T must be an integral type");\n}\n\nint main() {\n    check_type<int>();   // OK\n    // check_type<double>(); // Compile-time error: T must be an integral type\n    return 0;\n}\n')),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"3-concepts-in-c20"},"3. ",(0,i.kt)("strong",{parentName:"h3"},"Concepts in C++20")),(0,i.kt)("p",null,"The talk explores ",(0,i.kt)("strong",{parentName:"p"},"Concepts"),", a feature introduced in C++20, which allows developers to specify constraints on template arguments more succinctly and expressively compared to SFINAE. Concepts help in making templates more readable and the error messages more comprehensible."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Points"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Concepts")," define requirements for template parameters, making templates easier to understand and use."),(0,i.kt)("li",{parentName:"ul"},"Concepts improve the clarity of both template definitions and error messages.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"C++ Example"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <concepts>\n#include <iostream>\n\ntemplate<typename T>\nconcept Arithmetic = std::is_arithmetic_v<T>;\n\ntemplate<Arithmetic T>\nT add(T a, T b) {\n    return a + b;\n}\n\nint main() {\n    std::cout << add(5, 3) << std::endl;     // OK: int is arithmetic\n    // std::cout << add("Hello", "World");   // Error: concept \'Arithmetic\' not satisfied\n    return 0;\n}\n')),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"4-polymorphism-and-crtp"},"4. ",(0,i.kt)("strong",{parentName:"h3"},"Polymorphism and CRTP")),(0,i.kt)("p",null,"The talk covers ",(0,i.kt)("strong",{parentName:"p"},"polymorphism")," and the ",(0,i.kt)("strong",{parentName:"p"},"Curiously Recurring Template Pattern (CRTP)"),", a technique where a class template is derived from itself. CRTP allows for static polymorphism at compile time, which can offer performance benefits over dynamic polymorphism."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Points"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Runtime Polymorphism"),": Achieved using inheritance and virtual functions, but comes with runtime overhead due to the use of vtables."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"CRTP"),": A pattern that enables polymorphism at compile-time, avoiding the overhead of vtables.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"C++ Example"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\n// CRTP Base class\ntemplate<typename Derived>\nclass Base {\npublic:\n    void interface() {\n        static_cast<Derived*>(this)->implementation();\n    }\n    \n    static void staticInterface() {\n        Derived::staticImplementation();\n    }\n};\n\nclass Derived1 : public Base<Derived1> {\npublic:\n    void implementation() {\n        std::cout << "Derived1 implementation" << std::endl;\n    }\n    \n    static void staticImplementation() {\n        std::cout << "Derived1 static implementation" << std::endl;\n    }\n};\n\nclass Derived2 : public Base<Derived2> {\npublic:\n    void implementation() {\n        std::cout << "Derived2 implementation" << std::endl;\n    }\n    \n    static void staticImplementation() {\n        std::cout << "Derived2 static implementation" << std::endl;\n    }\n};\n\nint main() {\n    Derived1 d1;\n    d1.interface();\n    Derived1::staticInterface();\n\n    Derived2 d2;\n    d2.interface();\n    Derived2::staticInterface();\n\n    return 0;\n}\n')),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"5-deducing-this-in-c23"},"5. ",(0,i.kt)("strong",{parentName:"h3"},"Deducing ",(0,i.kt)("inlineCode",{parentName:"strong"},"this")," in C++23")),(0,i.kt)("p",null,"The discussion moves to ",(0,i.kt)("strong",{parentName:"p"},"deducing ",(0,i.kt)("inlineCode",{parentName:"strong"},"this")),", a feature introduced in C++23 that allows for more expressive syntax when working with member functions, particularly in the context of templates."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Points"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Deducing ",(0,i.kt)("inlineCode",{parentName:"strong"},"this"))," enables more flexible and readable template code involving member functions."),(0,i.kt)("li",{parentName:"ul"},"This feature simplifies the syntax when ",(0,i.kt)("inlineCode",{parentName:"li"},"this")," needs to be deduced as part of template metaprogramming.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"C++ Example"),":"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n\nclass MyClass {\npublic:\n    auto myMethod() const -> decltype(auto) {\n        return [this] { return *this; };\n    }\n    \n    void print() const {\n        std::cout << "MyClass instance" << std::endl;\n    }\n};\n\nint main() {\n    MyClass obj;\n    auto f = obj.myMethod();\n    f().print();  // Outputs: MyClass instance\n    return 0;\n}\n')),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"6-design-methodologies-procedural-oop-functional-and-data-oriented-design"},"6. ",(0,i.kt)("strong",{parentName:"h3"},"Design Methodologies: Procedural, OOP, Functional, and Data-Oriented Design")),(0,i.kt)("p",null,"The final section of the talk compares various ",(0,i.kt)("strong",{parentName:"p"},"design methodologies")," including ",(0,i.kt)("strong",{parentName:"p"},"Procedural"),", ",(0,i.kt)("strong",{parentName:"p"},"Object-Oriented Programming (OOP)"),", ",(0,i.kt)("strong",{parentName:"p"},"Functional Programming (FP)"),", and ",(0,i.kt)("strong",{parentName:"p"},"Data-Oriented Design (DOD)"),". Each paradigm has its strengths and use cases, and modern C++ often blends these methodologies to achieve optimal results."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Points"),":"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Procedural Programming"),": Focuses on a sequence of steps or procedures to accomplish tasks."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Object-Oriented Programming (OOP)"),": Organizes code around objects and data encapsulation."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Functional Programming (FP)"),": Emphasizes immutability and function composition."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"Data-Oriented Design (DOD)"),": Focuses on data layout in memory for performance, often used in game development.")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"C++ Example")," (Object-Oriented):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <vector>\n\nclass Telemetry {\npublic:\n    virtual void process() const = 0;\n};\n\nclass InstantaneousEvent : public Telemetry {\npublic:\n    void process() const override {\n        std::cout << "Processing instantaneous event" << std::endl;\n    }\n};\n\nclass LongTermEvent : public Telemetry {\npublic:\n    void process() const override {\n        std::cout << "Processing long-term event" << std::endl;\n    }\n};\n\nvoid processEvents(const std::vector<Telemetry*>& events) {\n    for (const auto& event : events) {\n        event->process();\n    }\n}\n\nint main() {\n    std::vector<Telemetry*> events = { new InstantaneousEvent(), new LongTermEvent() };\n    processEvents(events);\n    \n    for (auto event : events) {\n        delete event;\n    }\n    \n    return 0;\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"C++ Example")," (Functional Programming):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <vector>\n#include <algorithm>\n\nstruct Event {\n    int time;\n    bool isLongTerm;\n};\n\nvoid processEvents(const std::vector<Event>& events) {\n    std::for_each(events.begin(), events.end(), [](const Event& event) {\n        if (event.isLongTerm) {\n            std::cout << "Processing long-term event at time " << event.time << std::endl;\n        } else {\n            std::cout << "Processing instantaneous event at time " << event.time << std::endl;\n        }\n    });\n}\n\nint main() {\n    std::vector<Event> events = { {1, false}, {2, true}, {3, false} };\n    processEvents(events);\n    return 0;\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"C++ Example")," (Data-Oriented Design):"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'#include <iostream>\n#include <vector>\n\nstruct TelemetryData {\n    std::vector<int> instantaneousTimes;\n    std::vector<int> longTermTimes;\n};\n\nvoid processInstantaneous(const std::vector<int>& times) {\n    for (int time : times) {\n        std::cout << "Processing instantaneous event at time " << time << std::endl;\n    }\n}\n\nvoid processLongTerm(const std::vector<int>& times) {\n    for (int time : times) {\n        std::cout << "Processing long-term event at time " << time << std::endl;\n    }\n}\n\nint main() {\n    TelemetryData data = {\n\n\n        { 1, 3, 5 },\n        { 2, 4, 6 }\n    };\n    \n    processInstantaneous(data.instantaneousTimes);\n    processLongTerm(data.longTermTimes);\n    \n    return 0;\n}\n')),(0,i.kt)("hr",null),(0,i.kt)("h2",{id:"gpt-generated-content-with-a-bit-of-hallucinations"},'GPT generated content (with a bit of "hallucinations")'),(0,i.kt)("p",null,"Here's the expanded digest with essential text and detailed code examples for each point, focusing on modern replacements for legacy C++ practices."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Pointers vs. Smart Pointers")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Use of raw pointers, manual memory management, and explicit ",(0,i.kt)("inlineCode",{parentName:"p"},"new")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"delete"),". This can lead to memory leaks, dangling pointers, and undefined behavior."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Use smart pointers like ",(0,i.kt)("inlineCode",{parentName:"p"},"std::unique_ptr"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"std::shared_ptr"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"std::weak_ptr")," to manage dynamic memory automatically."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Legacy code\nclass LegacyClass {\n    int* data;\npublic:\n    LegacyClass() { data = new int[10]; }\n    ~LegacyClass() { delete[] data; }\n};\n\n// Modern code\n#include <memory>\n\nclass ModernClass {\n    std::unique_ptr<int[]> data;\npublic:\n    ModernClass() : data(std::make_unique<int[]>(10)) {}\n    // Destructor not needed, as std::unique_ptr handles memory automatically\n};\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," Using smart pointers reduces the need for manual memory management, preventing common errors like memory leaks and dangling pointers."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"C-Style Arrays vs. STL Containers")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Use of C-style arrays, which require manual memory management and do not provide bounds checking."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Use ",(0,i.kt)("inlineCode",{parentName:"p"},"std::vector")," for dynamic arrays or ",(0,i.kt)("inlineCode",{parentName:"p"},"std::array")," for fixed-size arrays. These containers handle memory management internally and offer bounds checking."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Legacy code\nint arr[10];\nfor (int i = 0; i < 10; ++i) {\n    arr[i] = i * 2;\n}\n\n// Modern code\n#include <vector>\n#include <array>\n\nstd::vector<int> vec(10);\nfor (int i = 0; i < 10; ++i) {\n    vec[i] = i * 2;\n}\n\nstd::array<int, 10> arr2;\nfor (int i = 0; i < 10; ++i) {\n    arr2[i] = i * 2;\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," STL containers provide better safety and ease of use compared to traditional arrays, and should be the default choice in modern C++."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Manual Error Handling vs. Exceptions and ",(0,i.kt)("inlineCode",{parentName:"strong"},"std::expected"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Return codes or error flags to indicate failures, which can be cumbersome and error-prone."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Use exceptions for error handling, which separate normal flow from error-handling code. Use ",(0,i.kt)("inlineCode",{parentName:"p"},"std::expected")," (from C++23) for functions that can either return a value or an error."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Legacy code\nint divide(int a, int b, bool& success) {\n    if (b == 0) {\n        success = false;\n        return 0;\n    }\n    success = true;\n    return a / b;\n}\n\n// Modern code with exceptions\nint divide(int a, int b) {\n    if (b == 0) throw std::runtime_error("Division by zero");\n    return a / b;\n}\n\n// Modern code with std::expected (C++23)\n#include <expected>\n\nstd::expected<int, std::string> divide(int a, int b) {\n    if (b == 0) return std::unexpected("Division by zero");\n    return a / b;\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," Exceptions and ",(0,i.kt)("inlineCode",{parentName:"p"},"std::expected")," offer more explicit and manageable error handling, improving code clarity and robustness."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Void Pointers vs. Type-Safe Programming")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Use of ",(0,i.kt)("inlineCode",{parentName:"p"},"void*")," for generic programming, leading to unsafe code and difficult debugging."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Use templates for type-safe generic programming, ensuring that code is checked at compile time."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Legacy code\nvoid process(void* data, int type) {\n    if (type == 1) {\n        int* intPtr = static_cast<int*>(data);\n        // Process int\n    } else if (type == 2) {\n        double* dblPtr = static_cast<double*>(data);\n        // Process double\n    }\n}\n\n// Modern code\ntemplate <typename T>\nvoid process(T data) {\n    // Process data safely with type known at compile time\n}\n\nint main() {\n    process(10);      // Automatically deduces int\n    process(5.5);     // Automatically deduces double\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," Templates provide type safety, ensuring errors are caught at compile time and making code easier to maintain."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Inheritance vs. Composition and Type Erasure")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Deep inheritance hierarchies, which can lead to rigid designs and hard-to-maintain code."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Favor composition over inheritance. Use type erasure (e.g., ",(0,i.kt)("inlineCode",{parentName:"p"},"std::function"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"std::any"),") or ",(0,i.kt)("inlineCode",{parentName:"p"},"std::variant")," to achieve polymorphism without inheritance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Legacy code\nclass Base {\npublic:\n    virtual void doSomething() = 0;\n};\n\nclass Derived : public Base {\npublic:\n    void doSomething() override {\n        // Implementation\n    }\n};\n\n// Modern code using composition\nclass Action {\n    std::function<void()> func;\npublic:\n    Action(std::function<void()> f) : func(f) {}\n    void execute() { func(); }\n};\n\nAction a([]() { /* Implementation */ });\na.execute();\n\n// Modern code using std::variant\n#include <variant>\n\nusing MyVariant = std::variant<int, double, std::string>;\n\nvoid process(const MyVariant& v) {\n    std::visit([](auto&& arg) {\n        // Implementation for each type\n    }, v);\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," Composition and type erasure lead to more flexible and maintainable designs than traditional deep inheritance hierarchies."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Global Variables vs. Dependency Injection")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Use of global variables for shared state, which can lead to hard-to-track bugs and dependencies."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Use dependency injection to provide dependencies explicitly, improving testability and modularity."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Legacy code\nint globalCounter = 0;\n\nvoid increment() {\n    globalCounter++;\n}\n\n// Modern code using dependency injection\nclass Counter {\n    int count;\npublic:\n    Counter() : count(0) {}\n    void increment() { ++count; }\n    int getCount() const { return count; }\n};\n\nvoid useCounter(Counter& counter) {\n    counter.increment();\n}\n\nint main() {\n    Counter c;\n    useCounter(c);\n    std::cout << c.getCount();\n}\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," Dependency injection enhances modularity and testability by explicitly providing dependencies rather than relying on global state."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Macros vs. ",(0,i.kt)("inlineCode",{parentName:"strong"},"constexpr")," and Inline Functions")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Extensive use of macros for constants and inline code, which can lead to debugging challenges and obscure code."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Use ",(0,i.kt)("inlineCode",{parentName:"p"},"constexpr")," for compile-time constants and inline functions for inline code, which are type-safe and easier to debug."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Legacy code\n#define SQUARE(x) ((x) * (x))\n\n// Modern code using constexpr\nconstexpr int square(int x) {\n    return x * x;\n}\n\n// Legacy code using macro for constant\n#define MAX_SIZE 100\n\n// Modern code using constexpr\nconstexpr int maxSize = 100;\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"constexpr")," and inline functions offer better type safety and are easier to debug compared to macros, making the code more maintainable."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Manual Resource Management vs. RAII (Resource Acquisition Is Initialization)")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Manual resource management, requiring explicit release of resources like files, sockets, and memory."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Use RAII, where resources are tied to object lifetime and automatically released when the object goes out of scope."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Legacy code\nFILE* file = fopen("data.txt", "r");\nif (file) {\n    // Use file\n    fclose(file);\n}\n\n// Modern code using RAII with std::fstream\n#include <fstream>\n\n{\n    std::ifstream file("data.txt");\n    if (file.is_open()) {\n        // Use file\n    } // File is automatically closed when going out of scope\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," RAII automates resource management, reducing the risk of resource leaks and making code more reliable."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Explicit Loops vs. Algorithms and Ranges")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Manual loops for operations like filtering, transforming, or accumulating data."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Use STL algorithms (",(0,i.kt)("inlineCode",{parentName:"p"},"std::transform"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"std::accumulate"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"std::copy_if"),") and ranges (C++20) to express intent more clearly and concisely."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Legacy code\nstd::vector<int> vec = {1, 2, 3, 4, 5};\nstd::vector<int> result;\n\nfor (auto i : vec) {\n    if (i % 2 == 0) result.push_back(i * 2);\n}\n\n// Modern code using algorithms\n#include <algorithm>\n#include <vector>\n\nstd::vector<int> vec = {1, 2, 3, 4, 5};\nstd::vector<int> result;\n\nstd::transform(vec.begin(), vec.end(), std::back_inserter(result),\n               [](int x) { return x % 2 == 0 ? x * 2 : 0; });\nresult.erase(std::remove(result.begin(), result.end(), 0), result.end());\n\n// Modern code using ranges (C++20)\n#include <ranges>\n\nauto result = vec | std::views::filter([](int x) { return x % 2 == 0; })\n                  | std::views::transform([](int x) { return x * 2; });\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," STL algorithms and ranges make code more expressive and concise, reducing the likelihood of errors and enhancing readability."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Manual String Manipulation vs. ",(0,i.kt)("inlineCode",{parentName:"strong"},"std::string")," and ",(0,i.kt)("inlineCode",{parentName:"strong"},"std::string_view"))),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Use of ",(0,i.kt)("inlineCode",{parentName:"p"},"char*")," and"),(0,i.kt)("p",null," manual string manipulation with functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"strcpy"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"strcat"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"strcmp"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Use ",(0,i.kt)("inlineCode",{parentName:"p"},"std::string")," for dynamic strings and ",(0,i.kt)("inlineCode",{parentName:"p"},"std::string_view")," for non-owning string references, which offer safer and more convenient string handling."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},'// Legacy code\nchar str1[20] = "Hello, ";\nchar str2[] = "world!";\nstrcat(str1, str2);\nif (strcmp(str1, "Hello, world!") == 0) {\n    // Do something\n}\n\n// Modern code using std::string\n#include <string>\n\nstd::string str1 = "Hello, ";\nstd::string str2 = "world!";\nstr1 += str2;\nif (str1 == "Hello, world!") {\n    // Do something\n}\n\n// Modern code using std::string_view (C++17)\n#include <string_view>\n\nstd::string_view strView = str1;\nif (strView == "Hello, world!") {\n    // Do something\n}\n')),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"std::string")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"std::string_view")," simplify string handling, provide better safety, and eliminate the risks associated with manual C-style string manipulation."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Threading with Raw Threads vs. ",(0,i.kt)("inlineCode",{parentName:"strong"},"std::thread")," and Concurrency Utilities")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Creating and managing threads manually using platform-specific APIs, which can be error-prone and non-portable."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Use ",(0,i.kt)("inlineCode",{parentName:"p"},"std::thread")," and higher-level concurrency utilities like ",(0,i.kt)("inlineCode",{parentName:"p"},"std::future"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"std::async"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"std::mutex")," to manage threading in a portable and safe way."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Legacy code (Windows example)\n#include <windows.h>\n\nDWORD WINAPI threadFunc(LPVOID lpParam) {\n    // Thread code\n    return 0;\n}\n\nHANDLE hThread = CreateThread(NULL, 0, threadFunc, NULL, 0, NULL);\n\n// Modern code using std::thread\n#include <thread>\n\nvoid threadFunc() {\n    // Thread code\n}\n\nstd::thread t(threadFunc);\nt.join();  // Wait for thread to finish\n\n// Modern code using std::async\n#include <future>\n\nauto future = std::async(std::launch::async, threadFunc);\nfuture.get();  // Wait for async task to finish\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"std::thread")," and other concurrency utilities provide a portable and higher-level interface for multithreading, reducing the complexity and potential errors associated with manual thread management."),(0,i.kt)("hr",null),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Function Pointers vs. ",(0,i.kt)("inlineCode",{parentName:"strong"},"std::function")," and Lambdas")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Legacy Practice:")," Use of function pointers to pass functions as arguments or store them in data structures, which can be cumbersome and less flexible."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Modern Replacement:")," Use ",(0,i.kt)("inlineCode",{parentName:"p"},"std::function")," to store callable objects, and lambdas to create inline, anonymous functions."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-cpp"},"// Legacy code\nvoid (*funcPtr)(int) = someFunction;\nfuncPtr(10);\n\n// Modern code using std::function and lambdas\n#include <functional>\n#include <iostream>\n\nstd::function<void(int)> func = [](int x) { std::cout << x << std::endl; };\nfunc(10);\n")),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Key Insight:")," ",(0,i.kt)("inlineCode",{parentName:"p"},"std::function")," and lambdas offer a more flexible and powerful way to handle functions as first-class objects, making code more modular and expressive."))}u.isMDXComponent=!0},88099:function(e,n,t){n.Z=t.p+"assets/images/image-20240901150003068-1948616fbb94cc23b5fddeb5b3d25b9e.png"}}]);