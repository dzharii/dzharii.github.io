"use strict";(self.webpackChunkzharii=self.webpackChunkzharii||[]).push([[5301],{96080:function(e,n,t){t.d(n,{Zo:function(){return d},kt:function(){return f}});var i=t(667);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function a(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);n&&(i=i.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,i)}return t}function s(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?a(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):a(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function o(e,n){if(null==e)return{};var t,i,r=function(e,n){if(null==e)return{};var t,i,r={},a=Object.keys(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(i=0;i<a.length;i++)t=a[i],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var l=i.createContext({}),c=function(e){var n=i.useContext(l),t=n;return e&&(t="function"==typeof e?e(n):s(s({},n),e)),t},d=function(e){var n=c(e.components);return i.createElement(l.Provider,{value:n},e.children)},u={inlineCode:"code",wrapper:function(e){var n=e.children;return i.createElement(i.Fragment,{},n)}},p=i.forwardRef((function(e,n){var t=e.components,r=e.mdxType,a=e.originalType,l=e.parentName,d=o(e,["components","mdxType","originalType","parentName"]),p=c(t),f=r,m=p["".concat(l,".").concat(f)]||p[f]||u[f]||a;return t?i.createElement(m,s(s({ref:n},d),{},{components:t})):i.createElement(m,s({ref:n},d))}));function f(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var a=t.length,s=new Array(a);s[0]=p;var o={};for(var l in n)hasOwnProperty.call(n,l)&&(o[l]=n[l]);o.originalType=e,o.mdxType="string"==typeof e?e:r,s[1]=o;for(var c=2;c<a;c++)s[c]=t[c];return i.createElement.apply(null,s)}return i.createElement.apply(null,t)}p.displayName="MDXCreateElement"},94422:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return o},contentTitle:function(){return l},metadata:function(){return c},toc:function(){return d},default:function(){return p}});var i=t(54570),r=t(89462),a=(t(667),t(96080)),s=["components"],o={},l="c99-vibecoded-test-report.md",c={unversionedId:"c99-vibecoded-test-report",id:"c99-vibecoded-test-report",title:"c99-vibecoded-test-report.md",description:"2025-11-02",source:"@site/docs/c99-vibecoded-test-report.md",sourceDirName:".",slug:"/c99-vibecoded-test-report",permalink:"/docs/c99-vibecoded-test-report",editUrl:"https://github.com/dzharii/dzharii.github.io/docs/c99-vibecoded-test-report.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"\ud83d\udccc Bookmarks",permalink:"/docs/bookmarks"},next:{title:"Cheat-sheets",permalink:"/docs/cheatsheets"}},d=[{value:"0. Build and environment snapshot",id:"0-build-and-environment-snapshot",children:[{value:"Probe",id:"probe",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt",children:[],level:3},{value:"Compiler and language macros",id:"compiler-and-language-macros",children:[],level:3},{value:"Target and pointer width",id:"target-and-pointer-width",children:[],level:3},{value:"Endianness probe",id:"endianness-probe",children:[],level:3},{value:"Observed output",id:"observed-output",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-1",children:[],level:3},{value:"Floating model",id:"floating-model",children:[],level:3}],level:2},{value:"1. Fundamental limits and properties",id:"1-fundamental-limits-and-properties",children:[{value:"Probe",id:"probe-1",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-2",children:[],level:3},{value:"Integer limits",id:"integer-limits",children:[],level:3},{value:"Floating limits and relations",id:"floating-limits-and-relations",children:[],level:3},{value:"Sizes and alignment of fundamental types",id:"sizes-and-alignment-of-fundamental-types",children:[],level:3}],level:2},{value:"2. Literals and lexical behaviors",id:"2-literals-and-lexical-behaviors",children:[{value:"Probe: character and string literal basics",id:"probe-character-and-string-literal-basics",children:[],level:3},{value:"Observed output",id:"observed-output-1",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-3",children:[],level:3},{value:"Integer literal types and bases",id:"integer-literal-types-and-bases",children:[],level:3},{value:"Floating literal suffixes",id:"floating-literal-suffixes",children:[],level:3},{value:"Wide string basics",id:"wide-string-basics",children:[],level:3}],level:2},{value:"3. Type system highlights",id:"3-type-system-highlights",children:[{value:"Probe",id:"probe-2",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-4",children:[],level:3},{value:"Signedness of plain char",id:"signedness-of-plain-char",children:[],level:3},{value:"_Bool and stdbool semantics",id:"_bool-and-stdbool-semantics",children:[],level:3},{value:"Qualifiers and restrict",id:"qualifiers-and-restrict",children:[],level:3},{value:"Observed output",id:"observed-output-2",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-5",children:[],level:3}],level:2},{value:"4. sizeof and alignment micro-experiments",id:"4-sizeof-and-alignment-micro-experiments",children:[{value:"Probe",id:"probe-3",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-6",children:[],level:3},{value:"Scalars",id:"scalars",children:[],level:3},{value:"Pointers and function pointers",id:"pointers-and-function-pointers",children:[],level:3},{value:"Fixed arrays",id:"fixed-arrays",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-7",children:[],level:3},{value:"VLA at runtime",id:"vla-at-runtime",children:[],level:3},{value:"Structs and unions, flexible array host",id:"structs-and-unions-flexible-array-host",children:[],level:3}],level:2},{value:"5. Struct layout, padding, and flexible arrays",id:"5-struct-layout-padding-and-flexible-arrays",children:[{value:"Probe",id:"probe-4",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-8",children:[],level:3},{value:"offsetof and padding gaps",id:"offsetof-and-padding-gaps",children:[],level:3},{value:"Copy, assign, and equality",id:"copy-assign-and-equality",children:[],level:3},{value:"Bit-fields packing and signedness",id:"bit-fields-packing-and-signedness",children:[],level:3},{value:"Flexible array idiom allocation",id:"flexible-array-idiom-allocation",children:[],level:3}],level:2},{value:"6. Unions and aliasing observations",id:"6-unions-and-aliasing-observations",children:[{value:"Probe",id:"probe-5",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-9",children:[],level:3},{value:"Active member and overlap illustration",id:"active-member-and-overlap-illustration",children:[],level:3},{value:"Representations via memcpy, avoiding aliasing UB",id:"representations-via-memcpy-avoiding-aliasing-ub",children:[],level:3},{value:"Common initial sequence",id:"common-initial-sequence",children:[],level:3}],level:2},{value:"7. Expressions and conversions",id:"7-expressions-and-conversions",children:[{value:"Probe",id:"probe-6",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-10",children:[],level:3},{value:"Integer promotions",id:"integer-promotions",children:[],level:3},{value:"Usual arithmetic conversions",id:"usual-arithmetic-conversions",children:[],level:3},{value:"Floating promotions in variadics",id:"floating-promotions-in-variadics",children:[],level:3},{value:"Conversions and negatives",id:"conversions-and-negatives",children:[],level:3},{value:"Ternary operator type resolution",id:"ternary-operator-type-resolution",children:[],level:3}],level:2},{value:"8. Operators, evaluation, and sequencing",id:"8-operators-evaluation-and-sequencing",children:[{value:"Probe",id:"probe-7",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-11",children:[],level:3},{value:"Pre and post increment in sequenced contexts",id:"pre-and-post-increment-in-sequenced-contexts",children:[],level:3},{value:"Short-circuiting",id:"short-circuiting",children:[],level:3},{value:"Bit shifts",id:"bit-shifts",children:[],level:3},{value:"sizeof on expressions is unevaluated",id:"sizeof-on-expressions-is-unevaluated",children:[],level:3}],level:2},{value:"9. Control flow probes",id:"9-control-flow-probes",children:[{value:"Probe",id:"probe-8",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-12",children:[],level:3},{value:"for, while, do-while",id:"for-while-do-while",children:[],level:3},{value:"switch and fallthrough",id:"switch-and-fallthrough",children:[],level:3},{value:"break and continue in nested loops",id:"break-and-continue-in-nested-loops",children:[],level:3}],level:2},{value:"10. Storage duration and initialization",id:"10-storage-duration-and-initialization",children:[{value:"Probe",id:"probe-9",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-13",children:[],level:3},{value:"Static local initialization once",id:"static-local-initialization-once",children:[],level:3},{value:"Static-duration zero initialization",id:"static-duration-zero-initialization",children:[],level:3},{value:"Linkage note",id:"linkage-note",children:[],level:3},{value:"Lifetime boundaries and safe copy",id:"lifetime-boundaries-and-safe-copy",children:[],level:3}],level:2},{value:"11. Arrays, pointers, and decay rules",id:"11-arrays-pointers-and-decay-rules",children:[{value:"Probe",id:"probe-10",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-14",children:[],level:3},{value:"Array to pointer decay",id:"array-to-pointer-decay",children:[],level:3},{value:"Pointer arithmetic scale factor",id:"pointer-arithmetic-scale-factor",children:[],level:3},{value:"1D and 2D row-major layout",id:"1d-and-2d-row-major-layout",children:[],level:3},{value:"VLA pass-through",id:"vla-pass-through",children:[],level:3},{value:"strlen vs sizeof for strings",id:"strlen-vs-sizeof-for-strings",children:[],level:3}],level:2},{value:"12. Functions and calling patterns",id:"12-functions-and-calling-patterns",children:[{value:"Probe",id:"probe-11",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-15",children:[],level:3},{value:"Function pointers",id:"function-pointers",children:[],level:3},{value:"Inline functions in one TU",id:"inline-functions-in-one-tu",children:[],level:3},{value:"Variadic function and default promotions",id:"variadic-function-and-default-promotions",children:[],level:3}],level:2},{value:"13. qsort and bsearch on arrays",id:"13-qsort-and-bsearch-on-arrays",children:[{value:"Probe",id:"probe-12",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-16",children:[],level:3},{value:"qsort of ints and instability note",id:"qsort-of-ints-and-instability-note",children:[],level:3},{value:"bsearch success and failure",id:"bsearch-success-and-failure",children:[],level:3}],level:2},{value:"14. Time basics",id:"14-time-basics",children:[{value:"Probe",id:"probe-13",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-17",children:[],level:3},{value:"time and localtime/gmtime",id:"time-and-localtimegmtime",children:[],level:3},{value:"clock and difftime",id:"clock-and-difftime",children:[],level:3}],level:2},{value:"15. Memory management and object lifetime",id:"15-memory-management-and-object-lifetime",children:[{value:"Probe",id:"probe-14",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-18",children:[],level:3},{value:"malloc alignment",id:"malloc-alignment",children:[],level:3},{value:"calloc zero-initialization vs malloc",id:"calloc-zero-initialization-vs-malloc",children:[],level:3},{value:"realloc growth and shrink",id:"realloc-growth-and-shrink",children:[],level:3},{value:"memmove vs memcpy with overlap",id:"memmove-vs-memcpy-with-overlap",children:[],level:3},{value:"memset on non-char objects",id:"memset-on-non-char-objects",children:[],level:3}],level:2},{value:"16. Strings and byte operations",id:"16-strings-and-byte-operations",children:[{value:"Probe",id:"probe-15",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-19",children:[],level:3},{value:"strlen with embedded NUL",id:"strlen-with-embedded-nul",children:[],level:3},{value:"strcpy and strncpy",id:"strcpy-and-strncpy",children:[],level:3},{value:"strcat with capacity check",id:"strcat-with-capacity-check",children:[],level:3},{value:"strchr, strrchr, strstr offsets",id:"strchr-strrchr-strstr-offsets",children:[],level:3},{value:"strtok statefulness",id:"strtok-statefulness",children:[],level:3}],level:2},{value:"17. Character classification and case conversion",id:"17-character-classification-and-case-conversion",children:[{value:"Probe",id:"probe-16",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-20",children:[],level:3},{value:"Classification table",id:"classification-table",children:[],level:3},{value:"Signed char trap",id:"signed-char-trap",children:[],level:3},{value:"toupper and tolower",id:"toupper-and-tolower",children:[],level:3}],level:2},{value:"18. Math library and special values",id:"18-math-library-and-special-values",children:[{value:"Probe",id:"probe-17",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-21",children:[],level:3},{value:"NaN propagation and finiteness",id:"nan-propagation-and-finiteness",children:[],level:3},{value:"Division by zero behavior",id:"division-by-zero-behavior",children:[],level:3},{value:"Rounding illustration",id:"rounding-illustration",children:[],level:3},{value:"hypot vs sqrt(x<em>x+y</em>y)",id:"hypot-vs-sqrtxxyy",children:[],level:3}],level:2},{value:"19. Random numbers",id:"19-random-numbers",children:[{value:"Probe",id:"probe-18",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-22",children:[],level:3},{value:"RAND_MAX and determinism",id:"rand_max-and-determinism",children:[],level:3},{value:"Modulo bias vs rejection sampling",id:"modulo-bias-vs-rejection-sampling",children:[],level:3}],level:2},{value:"20. Command-line arguments",id:"20-command-line-arguments",children:[{value:"Probe",id:"probe-19",children:[],level:3},{value:"Probe source excerpt",id:"probe-source-excerpt-23",children:[],level:3},{value:"argv echo",id:"argv-echo",children:[],level:3},{value:"strtol and strtod parsing",id:"strtol-and-strtod-parsing",children:[],level:3}],level:2},{value:"21. Portability and behavior categories index",id:"21-portability-and-behavior-categories-index",children:[],level:2},{value:"22. Source of this program",id:"22-source-of-this-program",children:[],level:2}],u={toc:d};function p(e){var n=e.components,t=(0,r.Z)(e,s);return(0,a.kt)("wrapper",(0,i.Z)({},u,t,{components:n,mdxType:"MDXLayout"}),(0,a.kt)("h1",{id:"c99-vibecoded-test-reportmd"},"c99-vibecoded-test-report.md"),(0,a.kt)("p",null,"2025-11-02"),(0,a.kt)("p",null,"This report is produced by running a single C99 program that executes small probes and prints Markdown."),(0,a.kt)("hr",null),(0,a.kt)("h2",{id:"0-build-and-environment-snapshot"},"0. Build and environment snapshot"),(0,a.kt)("h3",{id:"probe"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nPrint compiler and language macros; discover pointer width; probe endianness later.\nFloating model overview: FLT_RADIX and mantissa digits from <float.h>.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nPrint compiler and language macros; discover pointer width; probe endianness later.\nFloating model overview: FLT_RADIX and mantissa digits from <float.h>.\n*/\n\n")),(0,a.kt)("h3",{id:"compiler-and-language-macros"},"Compiler and language macros"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"compiler: unknown\n__STDC__ = 1\n__STDC_VERSION__ = 199901\n")),(0,a.kt)("h3",{id:"target-and-pointer-width"},"Target and pointer width"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"arch: x86_64\nsizeof(void*) = 8 bytes\n")),(0,a.kt)("h3",{id:"endianness-probe"},"Endianness probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nA simple, well-defined endianness probe:\n- Store 0x01020304 in a 32-bit object.\n- Read its representation via unsigned char*.\n- Interpret the first byte: 0x04 => little-endian; 0x01 => big-endian.\n*/\n\n")),(0,a.kt)("h3",{id:"observed-output"},"Observed output"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"bytes of 0x01020304: 4 3 2 1\nendianness: little-endian (implementation-defined)\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-1"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nA simple, well-defined endianness probe:\n- Store 0x01020304 in a 32-bit object.\n- Read its representation via unsigned char*.\n- Interpret the first byte: 0x04 => little-endian; 0x01 => big-endian.\n*/\n\n")),(0,a.kt)("h3",{id:"floating-model"},"Floating model"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"FLT_RADIX = 2\nFLT_MANT_DIG = 24, DBL_MANT_DIG = 53, LDBL_MANT_DIG = 64\nFLT_DIG = 6, DBL_DIG = 15, LDBL_DIG = 18\n")),(0,a.kt)("h2",{id:"1-fundamental-limits-and-properties"},"1. Fundamental limits and properties"),(0,a.kt)("h3",{id:"probe-1"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nQuery integer limits from <limits.h> and floating limits from <float.h>.\nSanity-check: FLT_MIN < 1.0f.\nPrint sizeof(T) and approximate alignment via offsetof(struct{char c; T t;}, t).\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-2"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nQuery integer limits from <limits.h> and floating limits from <float.h>.\nSanity-check: FLT_MIN < 1.0f.\nPrint sizeof(T) and approximate alignment via offsetof(struct{char c; T t;}, t).\n*/\n\n")),(0,a.kt)("h3",{id:"integer-limits"},"Integer limits"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"CHAR_BIT = 8\nSCHAR_MIN = -128, SCHAR_MAX = 127\nUCHAR_MAX = 255\nCHAR_MIN = -128, CHAR_MAX = 127\nSHRT_MIN = -32768, SHRT_MAX = 32767, USHRT_MAX = 65535\nINT_MIN = -2147483648, INT_MAX = 2147483647, UINT_MAX = 4294967295\nLONG_MIN = -2147483648, LONG_MAX = 2147483647, ULONG_MAX = 4294967295\nLLONG_MIN = -9223372036854775808, LLONG_MAX = 9223372036854775807, ULLONG_MAX = 18446744073709551615\n")),(0,a.kt)("h3",{id:"floating-limits-and-relations"},"Floating limits and relations"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"FLT_MIN = 1.175494e-038 < 1.0f => true\nDBL_MIN = 2.225074e-308 < 1.0  => true\nLDBL_MIN = 0.000000e+000 < 1.0L => true\n")),(0,a.kt)("h3",{id:"sizes-and-alignment-of-fundamental-types"},"Sizes and alignment of fundamental types"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"char               sizeof=1 align~= 1\nsigned char        sizeof=1 align~= 1\nunsigned char      sizeof=1 align~= 1\nshort              sizeof=2 align~= 2\nunsigned short     sizeof=2 align~= 2\nint                sizeof=4 align~= 4\nunsigned           sizeof=4 align~= 4\nlong               sizeof=4 align~= 4\nunsigned long      sizeof=4 align~= 4\nlong long          sizeof=8 align~= 8\nunsigned long long sizeof=8 align~= 8\nfloat              sizeof=4 align~= 4\ndouble             sizeof=8 align~= 8\nlong double        sizeof=8 align~= 8\nvoid*              sizeof=8 align~= 8\nsize_t             sizeof=8 align~= 8\nptrdiff_t          sizeof=8 align~= 8\nintptr_t           sizeof=8 align~= 8\nuintptr_t          sizeof=8 align~= 8\n")),(0,a.kt)("h2",{id:"2-literals-and-lexical-behaviors"},"2. Literals and lexical behaviors"),(0,a.kt)("h3",{id:"probe-character-and-string-literal-basics"},"Probe: character and string literal basics"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'/*\n- Character literals have type int in C, not char. sizeof(\'A\') is sizeof(int).\n- String literal concatenation happens at translation time: "hello" " " "world".\n- Embedded NUL in string literals affects strlen but not sizeof array initialization.\n*/\n\n')),(0,a.kt)("h3",{id:"observed-output-1"},"Observed output"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"'A' value=65 sizeof('A')=4\n'\\n' value=10\nL'A' sizeof element=2\n\"hello\" \" \" \"world\" => hello world\nstrlen(\"a\\0b\")=1, sizeof array=4\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-3"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'/*\n- Character literals have type int in C, not char. sizeof(\'A\') is sizeof(int).\n- String literal concatenation happens at translation time: "hello" " " "world".\n- Embedded NUL in string literals affects strlen but not sizeof array initialization.\n*/\n\n')),(0,a.kt)("h3",{id:"integer-literal-types-and-bases"},"Integer literal types and bases"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"")),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"sizeof 42 = 4\nsizeof 42U = 4\nsizeof 42L = 4\nsizeof 0xFFFFFFFF = 4 (implementation-defined)\noctal 077 => 63, hex 0x2A => 42\n")),(0,a.kt)("h3",{id:"floating-literal-suffixes"},"Floating literal suffixes"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"sizeof 1.0 = 8, sizeof 1.0f = 4, sizeof 1.0L = 8\n")),(0,a.kt)("h3",{id:"wide-string-basics"},"Wide string basics"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'sizeof L"abc" = 8 bytes, element size=2\n')),(0,a.kt)("h2",{id:"3-type-system-highlights"},"3. Type system highlights"),(0,a.kt)("h3",{id:"probe-2"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- The signedness of plain 'char' is implementation-defined.\n- _Bool is a distinct type; values are 0 or 1 after conversion.\n- Qualifiers like const/volatile do not change sizeof; 'restrict' is a promise\nabout non-overlapping pointed-to objects that can enable better optimization.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-4"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- The signedness of plain 'char' is implementation-defined.\n- _Bool is a distinct type; values are 0 or 1 after conversion.\n- Qualifiers like const/volatile do not change sizeof; 'restrict' is a promise\nabout non-overlapping pointed-to objects that can enable better optimization.\n*/\n\n")),(0,a.kt)("h3",{id:"signedness-of-plain-char"},"Signedness of plain char"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"plain char is signed\n")),(0,a.kt)("h3",{id:"_bool-and-stdbool-semantics"},"_Bool and stdbool semantics"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"_Bool b = 2 => stored as 1; !b = 0\n")),(0,a.kt)("h3",{id:"qualifiers-and-restrict"},"Qualifiers and restrict"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"")),(0,a.kt)("h3",{id:"observed-output-2"},"Observed output"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"after takes_restrict: a = {11,22,33}\nsizeof(int* restrict) == sizeof(int*) => 8 == 8\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-5"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n'restrict' qualifier on pointers promises that, for the lifetime of the pointers,\nonly they (or values derived from them) will be used to access the pointed-to objects.\nThis permits aliasing optimizations. It does not change the pointer's size or representation.\n*/\n\n")),(0,a.kt)("h2",{id:"4-sizeof-and-alignment-micro-experiments"},"4. sizeof and alignment micro-experiments"),(0,a.kt)("h3",{id:"probe-3"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nDemonstrate sizeof for scalars, pointers, arrays, VLAs, structs, unions,\nand a host struct with a flexible array member (FAM).\nAlignment approximated via offsetof(struct{char c; T t;}, t).\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-6"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nDemonstrate sizeof for scalars, pointers, arrays, VLAs, structs, unions,\nand a host struct with a flexible array member (FAM).\nAlignment approximated via offsetof(struct{char c; T t;}, t).\n*/\n\n")),(0,a.kt)("h3",{id:"scalars"},"Scalars"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"char               sizeof=1 align~= 1\nshort              sizeof=2 align~= 2\nint                sizeof=4 align~= 4\nlong               sizeof=4 align~= 4\nfloat              sizeof=4 align~= 4\ndouble             sizeof=8 align~= 8\nlong double        sizeof=8 align~= 8\n")),(0,a.kt)("h3",{id:"pointers-and-function-pointers"},"Pointers and function pointers"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"sizeof(int*)=8, sizeof(double*)=8, sizeof(fp)=8\n")),(0,a.kt)("h3",{id:"fixed-arrays"},"Fixed arrays"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"char a[3]                       3           1      3  elem size * count\nint a[3]                       12           4      3  elem size * count\ndouble a[3]                    24           8      3  elem size * count\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-7"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'{\nconst char *decl = "char a[3]";\nprintf("%-23s  %8zu     %7zu  %5d  elem size * count\\n",\ndecl, sizeof a1, sizeof a1[0], 3);\n}\n{\nconst char *decl = "int a[3]";\nprintf("%-23s  %8zu     %7zu  %5d  elem size * count\\n",\ndecl, sizeof a2, sizeof a2[0], 3);\n}\n{\nconst char *decl = "double a[3]";\nprintf("%-23s  %8zu     %7zu  %5d  elem size * count\\n",\ndecl, sizeof a3, sizeof a3[0], 3);\n}\n\n')),(0,a.kt)("h3",{id:"vla-at-runtime"},"VLA at runtime"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"n=7, sizeof vla = 28 (expect n*sizeof(int)=28)\n")),(0,a.kt)("h3",{id:"structs-and-unions-flexible-array-host"},"Structs and unions, flexible array host"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"struct A sizeof=8 sum(fields)=5 align~= 4 offsets: c=0 i=4\nstruct B sizeof=24 sum(fields)=13 align~= 8 offsets: c=0 d=8 i=16\nunion U sizeof=8 align~= 8 max(member sizes)=8\nstruct Flex host sizeof=8 (FAM contributes 0)\n")),(0,a.kt)("h2",{id:"5-struct-layout-padding-and-flexible-arrays"},"5. Struct layout, padding, and flexible arrays"),(0,a.kt)("h3",{id:"probe-4"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nUse offsetof to reveal padding. Compare assignment equality by fields, not memcmp.\nBit-fields: widths and signedness are implementation-defined.\nFlexible array member: allocate sizeof(header)+n*sizeof(elem) and access payload.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-8"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nUse offsetof to reveal padding. Compare assignment equality by fields, not memcmp.\nBit-fields: widths and signedness are implementation-defined.\nFlexible array member: allocate sizeof(header)+n*sizeof(elem) and access payload.\n*/\n\n")),(0,a.kt)("h3",{id:"offsetof-and-padding-gaps"},"offsetof and padding gaps"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"struct P sizeof=16 fields sum=13 offsets: c=0 i=4 d=8\n")),(0,a.kt)("h3",{id:"copy-assign-and-equality"},"Copy, assign, and equality"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"struct assignment copies fields; equal by fields => true\n")),(0,a.kt)("h3",{id:"bit-fields-packing-and-signedness"},"Bit-fields packing and signedness"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"BF sizeof=4, a=7, b=-3, c=42, first bytes 0x00002aef (implementation-defined)\n")),(0,a.kt)("h3",{id:"flexible-array-idiom-allocation"},"Flexible array idiom allocation"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"malloc(28) ok; usable ints=5; last=16\n")),(0,a.kt)("h2",{id:"6-unions-and-aliasing-observations"},"6. Unions and aliasing observations"),(0,a.kt)("h3",{id:"probe-5"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nReading a different union member than the one most recently written is\nimplementation-defined; we use it only to illustrate overlapping representation.\nFor non-integer bit patterns, use memcpy to a same-sized integer type.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-9"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nReading a different union member than the one most recently written is\nimplementation-defined; we use it only to illustrate overlapping representation.\nFor non-integer bit patterns, use memcpy to a same-sized integer type.\n*/\n\n")),(0,a.kt)("h3",{id:"active-member-and-overlap-illustration"},"Active member and overlap illustration"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"write u.u=0x41424344 then read bytes: 68 67 66 65 (implementation-defined)\n")),(0,a.kt)("h3",{id:"representations-via-memcpy-avoiding-aliasing-ub"},"Representations via memcpy, avoiding aliasing UB"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"double 1.5 bit pattern = 0x3ff8000000000000\n")),(0,a.kt)("h3",{id:"common-initial-sequence"},"Common initial sequence"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"common initial tag=7\n")),(0,a.kt)("h2",{id:"7-expressions-and-conversions"},"7. Expressions and conversions"),(0,a.kt)("h3",{id:"probe-6"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- Integer promotions: smaller integer types promote to int in expressions.\n- Usual arithmetic conversions: mixing signed and unsigned can convert to unsigned.\n- Variadic calls apply default promotions: float -> double, char/short -> int.\n- Division and modulo with negatives truncate toward zero per C99.\n- Ternary operator chooses a common type via usual arithmetic conversions.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-10"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- Integer promotions: smaller integer types promote to int in expressions.\n- Usual arithmetic conversions: mixing signed and unsigned can convert to unsigned.\n- Variadic calls apply default promotions: float -> double, char/short -> int.\n- Division and modulo with negatives truncate toward zero per C99.\n- Ternary operator chooses a common type via usual arithmetic conversions.\n*/\n\n")),(0,a.kt)("h3",{id:"integer-promotions"},"Integer promotions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"sizeof(c+s) => 4 (promotes to int)\n")),(0,a.kt)("h3",{id:"usual-arithmetic-conversions"},"Usual arithmetic conversions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"u=1 (unsigned), i=-2 (int), u+i as unsigned => 4294967295 (implementation-defined)\n")),(0,a.kt)("h3",{id:"floating-promotions-in-variadics"},"Floating promotions in variadics"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"printf %f receives double, float promoted: 1.250000\n")),(0,a.kt)("h3",{id:"conversions-and-negatives"},"Conversions and negatives"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"(int)3.9 = 3 (trunc toward zero)\n-7 / 3 = -2, -7 % 3 = -1\n")),(0,a.kt)("h3",{id:"ternary-operator-type-resolution"},"Ternary operator type resolution"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"sizeof( (1? 1 : 1.0) ) = 8 (to double)\nsizeof( (1? -1 : 1u) ) = 4 (implementation-defined)\n")),(0,a.kt)("h2",{id:"8-operators-evaluation-and-sequencing"},"8. Operators, evaluation, and sequencing"),(0,a.kt)("h3",{id:"probe-7"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nShow only well-defined uses:\n- Post-increment used once in an expression.\n- Short-circuiting prevents evaluation of the right operand when not needed.\n- Right shift of negative signed integers is implementation-defined.\n- sizeof does not evaluate its operand.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-11"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nShow only well-defined uses:\n- Post-increment used once in an expression.\n- Short-circuiting prevents evaluation of the right operand when not needed.\n- Right shift of negative signed integers is implementation-defined.\n- sizeof does not evaluate its operand.\n*/\n\n")),(0,a.kt)("h3",{id:"pre-and-post-increment-in-sequenced-contexts"},"Pre and post increment in sequenced contexts"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"x=1; y = x++ + 2 => y=3 x=2\n")),(0,a.kt)("h3",{id:"short-circuiting"},"Short-circuiting"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"0 && side_effect => v=0, counter=0 (rhs not evaluated)\n1 || side_effect => v=1, counter=0 (rhs not evaluated)\n")),(0,a.kt)("h3",{id:"bit-shifts"},"Bit shifts"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"unsigned right shift: (1u<<3)>>1 = 4\nsigned right shift of negative is implementation-defined; example (-4>>1)=-2\n")),(0,a.kt)("h3",{id:"sizeof-on-expressions-is-unevaluated"},"sizeof on expressions is unevaluated"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"after sizeof(t++), t=0 (no increment)\n")),(0,a.kt)("h2",{id:"9-control-flow-probes"},"9. Control flow probes"),(0,a.kt)("h3",{id:"probe-8"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nCount iterations for for/while/do-while to show entry semantics.\nDemonstrate switch fallthrough and nested-loop break/continue effects.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-12"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nCount iterations for for/while/do-while to show entry semantics.\nDemonstrate switch fallthrough and nested-loop break/continue effects.\n*/\n\n")),(0,a.kt)("h3",{id:"for-while-do-while"},"for, while, do-while"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"for=3 while=3 do-while=3\n")),(0,a.kt)("h3",{id:"switch-and-fallthrough"},"switch and fallthrough"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"x=2, fallthrough sum=6\n")),(0,a.kt)("h3",{id:"break-and-continue-in-nested-loops"},"break and continue in nested loops"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"outer=3 inner=6\n")),(0,a.kt)("h2",{id:"10-storage-duration-and-initialization"},"10. Storage duration and initialization"),(0,a.kt)("h3",{id:"probe-9"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- Static locals initialize once and retain value between calls.\n- Static-duration objects without explicit initializers are zero-initialized.\n- External linkage variable exists once per program.\n- Do not return pointer to a local; copy needed value to dynamic storage instead.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-13"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- Static locals initialize once and retain value between calls.\n- Static-duration objects without explicit initializers are zero-initialized.\n- External linkage variable exists once per program.\n- Do not return pointer to a local; copy needed value to dynamic storage instead.\n*/\n\n")),(0,a.kt)("h3",{id:"static-local-initialization-once"},"Static local initialization once"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"static_once() calls: 1 2 3\n")),(0,a.kt)("h3",{id:"static-duration-zero-initialization"},"Static-duration zero initialization"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"uninitialized static int = 0\n")),(0,a.kt)("h3",{id:"linkage-note"},"Linkage note"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"external_var has external linkage in this translation unit; value=0\n")),(0,a.kt)("h3",{id:"lifetime-boundaries-and-safe-copy"},"Lifetime boundaries and safe copy"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"copied value from dead frame = 42\n")),(0,a.kt)("h2",{id:"11-arrays-pointers-and-decay-rules"},"11. Arrays, pointers, and decay rules"),(0,a.kt)("h3",{id:"probe-10"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- Arrays decay to pointers in most expressions (including function calls).\n- Pointer arithmetic scales by sizeof(element); measure deltas within same array.\n- 2D arrays are row-major (rows contiguous).\n- VLAs have runtime size; sizeof(VLA) reflects runtime element count.\n- strlen stops at first NUL; sizeof(array) is full byte count.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-14"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- Arrays decay to pointers in most expressions (including function calls).\n- Pointer arithmetic scales by sizeof(element); measure deltas within same array.\n- 2D arrays are row-major (rows contiguous).\n- VLAs have runtime size; sizeof(VLA) reflects runtime element count.\n- strlen stops at first NUL; sizeof(array) is full byte count.\n*/\n\n")),(0,a.kt)("h3",{id:"array-to-pointer-decay"},"Array to pointer decay"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"in scope: sizeof(a)=16\nin function: parameter sizeof(a)=8 (pointer), n=4\n")),(0,a.kt)("h3",{id:"pointer-arithmetic-scale-factor"},"Pointer arithmetic scale factor"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"delta(&ai[1]-&ai[0])=4 bytes, delta(&ad[1]-&ad[0])=8 bytes\n")),(0,a.kt)("h3",{id:"1d-and-2d-row-major-layout"},"1D and 2D row-major layout"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"&m[0][0]=000000000060FD00, &m[0][1]=000000000060FD04, &m[1][0]=000000000060FD0C (row-major contiguous)\n")),(0,a.kt)("h3",{id:"vla-pass-through"},"VLA pass-through"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"VLA n=5, sizeof v = 20, first=42\n")),(0,a.kt)("h3",{id:"strlen-vs-sizeof-for-strings"},"strlen vs sizeof for strings"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"s1: strlen=3 sizeof=5; s2: strlen=1 sizeof=5\n")),(0,a.kt)("h2",{id:"12-functions-and-calling-patterns"},"12. Functions and calling patterns"),(0,a.kt)("h3",{id:"probe-11"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- Function pointers: take address and call through pointer.\n- static inline functions work within a single translation unit (C99).\n- Variadic functions: default promotions apply; printf returns chars written.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-15"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- Function pointers: take address and call through pointer.\n- static inline functions work within a single translation unit (C99).\n- Variadic functions: default promotions apply; printf returns chars written.\n*/\n\n")),(0,a.kt)("h3",{id:"function-pointers"},"Function pointers"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"square_fn(5) via pointer = 25, cube_fn(3) = 27\nsizeof(function pointer)=8 vs sizeof(void*)=8\n")),(0,a.kt)("h3",{id:"inline-functions-in-one-tu"},"Inline functions in one TU"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"add_inline(2,3) = 5\n")),(0,a.kt)("h3",{id:"variadic-function-and-default-promotions"},"Variadic function and default promotions"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"sum_variadic(a,b,c) = 6\nprintf returns chars written: hello => 39 + 6\n")),(0,a.kt)("h2",{id:"13-qsort-and-bsearch-on-arrays"},"13. qsort and bsearch on arrays"),(0,a.kt)("h3",{id:"probe-12"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nqsort requires a strict weak ordering comparator; it is not stable.\nbsearch requires the array to be sorted by the same comparator.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-16"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nqsort requires a strict weak ordering comparator; it is not stable.\nbsearch requires the array to be sorted by the same comparator.\n*/\n\n")),(0,a.kt)("h3",{id:"qsort-of-ints-and-instability-note"},"qsort of ints and instability note"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"sorted ints: 0 1 2 2 4 5 5 8\nrecords after qsort by key: {k=1,t=1} {k=1,t=2} {k=2,t=1} {k=2,t=2} (order of equal keys is unspecified)\n")),(0,a.kt)("h3",{id:"bsearch-success-and-failure"},"bsearch success and failure"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"bsearch 6 => found\nbsearch 7 => not found\n")),(0,a.kt)("h2",{id:"14-time-basics"},"14. Time basics"),(0,a.kt)("h3",{id:"probe-13"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\ntime() returns epoch seconds; localtime/gmtime convert to broken-down time; strftime formats.\nclock() measures CPU time used by the process; divide ticks by CLOCKS_PER_SEC.\ndifftime gives a double difference between two time_t values.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-17"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\ntime() returns epoch seconds; localtime/gmtime convert to broken-down time; strftime formats.\nclock() measures CPU time used by the process; divide ticks by CLOCKS_PER_SEC.\ndifftime gives a double difference between two time_t values.\n*/\n\n")),(0,a.kt)("h3",{id:"time-and-localtimegmtime"},"time and localtime/gmtime"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"time() = 1762068761\nlocaltime: 2025-11-02 00:32:41\ngmtime:   2025-11-02 07:32:41\n")),(0,a.kt)("h3",{id:"clock-and-difftime"},"clock and difftime"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"clock dt = 0.011000 seconds\ndifftime(now+3, now) = 3\n")),(0,a.kt)("h2",{id:"15-memory-management-and-object-lifetime"},"15. Memory management and object lifetime"),(0,a.kt)("h3",{id:"probe-14"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- malloc alignment suffices for any object type.\n- calloc zeroes memory; malloc leaves indeterminate bytes.\n- realloc may move or keep the same pointer; content preserved up to min(old,new).\n- memmove handles overlap; memcpy requires non-overlapping regions.\n- memset sets bytes; resulting int value from nonzero patterns is implementation-defined.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-18"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- malloc alignment suffices for any object type.\n- calloc zeroes memory; malloc leaves indeterminate bytes.\n- realloc may move or keep the same pointer; content preserved up to min(old,new).\n- memmove handles overlap; memcpy requires non-overlapping regions.\n- memset sets bytes; resulting int value from nonzero patterns is implementation-defined.\n*/\n\n")),(0,a.kt)("h3",{id:"malloc-alignment"},"malloc alignment"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"malloc ptr % alignment 8 = 0\n")),(0,a.kt)("h3",{id:"calloc-zero-initialization-vs-malloc"},"calloc zero-initialization vs malloc"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"malloc first 8 bytes: 20 00 00 00 14 00 00 00\ncalloc first 8 bytes: 00 00 00 00 00 00 00 00\n")),(0,a.kt)("h3",{id:"realloc-growth-and-shrink"},"realloc growth and shrink"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"realloc grow: moved=maybe\nrealloc shrink ok\n")),(0,a.kt)("h3",{id:"memmove-vs-memcpy-with-overlap"},"memmove vs memcpy with overlap"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"memmove overlap: ababcd\nmemcpy overlap: not executed to avoid UB; use memmove instead\n")),(0,a.kt)("h3",{id:"memset-on-non-char-objects"},"memset on non-char objects"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"memset int with 0xFF yields pattern, x=-1 (implementation-defined)\nmemset int with 0x01 yields pattern, x=16843009 (implementation-defined)\n")),(0,a.kt)("h2",{id:"16-strings-and-byte-operations"},"16. Strings and byte operations"),(0,a.kt)("h3",{id:"probe-15"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- strlen stops at the first NUL.\n- strcpy copies including the terminating NUL; strncpy may omit the NUL when truncated.\n- strcat appends (check capacity first).\n- strchr/strrchr/strstr return pointers; print offsets via pointer subtraction.\n- strtok is stateful and not re-entrant.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-19"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- strlen stops at the first NUL.\n- strcpy copies including the terminating NUL; strncpy may omit the NUL when truncated.\n- strcat appends (check capacity first).\n- strchr/strrchr/strstr return pointers; print offsets via pointer subtraction.\n- strtok is stateful and not re-entrant.\n*/\n\n")),(0,a.kt)("h3",{id:"strlen-with-embedded-nul"},"strlen with embedded NUL"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"strlen on {'a','b','\\0','c'} => 2\n")),(0,a.kt)("h3",{id:"strcpy-and-strncpy"},"strcpy and strncpy"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'strcpy dst1="abc"; strncpy fixed dst2="abc"\n')),(0,a.kt)("h3",{id:"strcat-with-capacity-check"},"strcat with capacity check"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'after safe strcat => "abcdef"\n')),(0,a.kt)("h3",{id:"strchr-strrchr-strstr-offsets"},"strchr, strrchr, strstr offsets"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'first a at 0, last a at 10, "cad" at 4\n')),(0,a.kt)("h3",{id:"strtok-statefulness"},"strtok statefulness"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"[a] [b] [c] \n")),(0,a.kt)("h2",{id:"17-character-classification-and-case-conversion"},"17. Character classification and case conversion"),(0,a.kt)("h3",{id:"probe-16"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nctype functions require inputs representable as unsigned char or EOF.\nPassing negative char values is undefined behavior; cast to unsigned char.\nWe print a small table and demonstrate the signed-char trap.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-20"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nctype functions require inputs representable as unsigned char or EOF.\nPassing negative char values is undefined behavior; cast to unsigned char.\nWe print a small table and demonstrate the signed-char trap.\n*/\n\n")),(0,a.kt)("h3",{id:"classification-table"},"Classification table"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"'A': isalpha=1 isdigit=0 isspace=0\n'1': isalpha=0 isdigit=1 isspace=0\n' ': isalpha=0 isdigit=0 isspace=1\n'   ': isalpha=0 isdigit=0 isspace=1\n'!': isalpha=0 isdigit=0 isspace=0\n")),(0,a.kt)("h3",{id:"signed-char-trap"},"Signed char trap"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"isalpha((char)0xFF) => 0, isalpha((unsigned char)0xFF) => 0\n")),(0,a.kt)("h3",{id:"toupper-and-tolower"},"toupper and tolower"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"toupper('a')=A, tolower('Z')=z\n")),(0,a.kt)("h2",{id:"18-math-library-and-special-values"},"18. Math library and special values"),(0,a.kt)("h3",{id:"probe-17"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- NaN propagates through arithmetic; classify with isnan/isfinite.\n- Floating division by zero yields +/-inf (int division by zero is undefined).\n- Repeated addition of 0.1 shows rounding error in binary floating point.\n- hypot(x,y) handles large arguments more robustly than sqrt(x*x+y*y).\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-21"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\n- NaN propagates through arithmetic; classify with isnan/isfinite.\n- Floating division by zero yields +/-inf (int division by zero is undefined).\n- Repeated addition of 0.1 shows rounding error in binary floating point.\n- hypot(x,y) handles large arguments more robustly than sqrt(x*x+y*y).\n*/\n\n")),(0,a.kt)("h3",{id:"nan-propagation-and-finiteness"},"NaN propagation and finiteness"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"NAN + 1 => isnan=1, isfinite=0\n")),(0,a.kt)("h3",{id:"division-by-zero-behavior"},"Division by zero behavior"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"1.0/0.0 => inf, sign=plus\n")),(0,a.kt)("h3",{id:"rounding-illustration"},"Rounding illustration"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"sum of 0.1 ten times = 0.99999999999999989000, difference vs 1.0 = -0.00000000000000011102\n")),(0,a.kt)("h3",{id:"hypot-vs-sqrtxxyy"},"hypot vs sqrt(x",(0,a.kt)("em",{parentName:"h3"},"x+y"),"y)"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"hypot=1.414e+200, sqrt-sum=1.#IOe+000\n")),(0,a.kt)("h2",{id:"19-random-numbers"},"19. Random numbers"),(0,a.kt)("h3",{id:"probe-18"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nsrand seeds the PRNG deterministically; rand() generates pseudo-random ints in [0, RAND_MAX].\nMapping to smaller ranges via modulo introduces bias unless divisible; rejection sampling avoids bias.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-22"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nsrand seeds the PRNG deterministically; rand() generates pseudo-random ints in [0, RAND_MAX].\nMapping to smaller ranges via modulo introduces bias unless divisible; rejection sampling avoids bias.\n*/\n\n")),(0,a.kt)("h3",{id:"rand_max-and-determinism"},"RAND_MAX and determinism"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"RAND_MAX=32767\nstream: 4068 213 12761 8758 23056\n")),(0,a.kt)("h3",{id:"modulo-bias-vs-rejection-sampling"},"Modulo bias vs rejection sampling"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"rand() % 6 => 1 (biased)\nrejection sampling into [0,6): 4 (unbiased)\n")),(0,a.kt)("h2",{id:"20-command-line-arguments"},"20. Command-line arguments"),(0,a.kt)("h3",{id:"probe-19"},"Probe"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nPrint argc and each argv quoted. Then parse with strtol/strtod, showing\nwhere parsing stops via endptr, without terminating on errors.\n*/\n\n")),(0,a.kt)("h3",{id:"probe-source-excerpt-23"},"Probe source excerpt"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},"/*\nPrint argc and each argv quoted. Then parse with strtol/strtod, showing\nwhere parsing stops via endptr, without terminating on errors.\n*/\n\n")),(0,a.kt)("h3",{id:"argv-echo"},"argv echo"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'argc=1\nargv[0] = "main.c"\n')),(0,a.kt)("h3",{id:"strtol-and-strtod-parsing"},"strtol and strtod parsing"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},'strtol("123x") => 123, stopped at "x"\nstrtod("3.14y") => 3.140000, stopped at "y"\n')),(0,a.kt)("h2",{id:"21-portability-and-behavior-categories-index"},"21. Portability and behavior categories index"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-text"},"Endianness: implementation-defined\nSigned right shift of negative: implementation-defined\nStruct layout and padding: implementation-defined\nUnion byte order view: implementation-defined\nSizes, integer and floating limits: defined\nVLA size and behavior: defined (if VLA supported by implementation)\nInteger literal width selection on 0xFFFFFFFF: implementation-defined\n")),(0,a.kt)("h2",{id:"22-source-of-this-program"},"22. Source of this program"),(0,a.kt)("pre",null,(0,a.kt)("code",{parentName:"pre",className:"language-c"},'/*\nC99 single-file exploratory cheatsheet\nGenerates a Markdown report by running micro-experiments at runtime.\n\nUpdates in this version:\n- Removed <complex.h> and all complex-number examples.\n- Added richer code examples for each sub-experiment with detailed context comments.\n- Avoids undefined behavior while still demonstrating implementation-defined or unspecified areas, clearly labeled.\n\nBuild:\n  cc -std=c99 -Wall -Wextra -pedantic -O2 cheatsheet.c -lm -o cheatsheet\nRun:\n  ./cheatsheet > report.md\n*/\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stddef.h>\n#include <stdint.h>\n#include <stdbool.h>\n#include <limits.h>\n#include <float.h>\n#include <inttypes.h>\n#include <stdarg.h>\n#include <time.h>\n#include <ctype.h>\n#include <math.h>\n#include <setjmp.h>\n\n/* ---------------- file loading ---------------- */\n\nstatic char *read_entire_file(const char *path) {\n    FILE *f = fopen(path, "rb");\n    if (!f) return NULL;\n    if (fseek(f, 0, SEEK_END) != 0) { fclose(f); return NULL; }\n    long sz = ftell(f);\n    if (sz < 0) { fclose(f); return NULL; }\n    if (fseek(f, 0, SEEK_SET) != 0) { fclose(f); return NULL; }\n    char *buf = (char*)malloc((size_t)sz + 1);\n    if (!buf) { fclose(f); return NULL; }\n    size_t rd = fread(buf, 1, (size_t)sz, f);\n    fclose(f);\n    buf[rd] = \'\\0\';\n    return buf;\n}\n\n/* ---------------- String_View and marker extractor ---------------- */\n\ntypedef struct {\n    const char *data;\n    size_t len;\n    int ok; /* 1 if found, 0 otherwise */\n} String_View;\n\n/* Finds region between:\n//#+begin_marker <id>\\n\n...content...\n//#+end_marker <id>\nExcludes marker lines. Works with LF or CRLF. */\nstatic String_View read_source_code(const char *buffer, const char *markerId) {\n    String_View sv = (String_View){ NULL, 0, 0 };\n    if (!buffer || !markerId) return sv;\n\n    char beginTag[64];\n    char endTag[64];\n    snprintf(beginTag, sizeof beginTag, "//#+begin_marker %s", markerId);\n    snprintf(endTag,   sizeof endTag,   "//#+end_marker %s",   markerId);\n\n    const char *begin = strstr(buffer, beginTag);\n    if (!begin) return sv;\n\n    const char *afterBeginLine = strchr(begin, \'\\n\');\n    if (!afterBeginLine) return sv;\n    afterBeginLine++;\n\n    const char *end = strstr(afterBeginLine, endTag);\n    if (!end) return sv;\n\n    /* Trim a single trailing newline before end tag for neatness */\n    const char *segEnd = end;\n    const char *p = segEnd;\n    if (p > afterBeginLine) {\n        if (*(p - 1) == \'\\n\') {\n            p--;\n            if (p > afterBeginLine && *(p - 1) == \'\\r\') p--;\n        }\n    }\n    sv.data = afterBeginLine;\n    sv.len  = (size_t)(p - afterBeginLine);\n    sv.ok   = 1;\n    return sv;\n}\n\n/* ---------------- dedent and normalize printer ---------------- */\n\n/* Print String_View as C code, converting CRLF to LF and stripping the\n   minimal common leading indentation (spaces and tabs) across non-empty lines. */\nstatic void print_sv_dedented_normalized(const char *data, size_t len) {\n    size_t i = 0;\n    size_t min_indent = (size_t)-1;\n    int have_nonempty = 0;\n\n    while (i < len) {\n        size_t indent = 0;\n        while (i < len && (data[i] == \' \' || data[i] == \'\\t\')) { indent++; i++; }\n        int is_empty = 0;\n        if (i >= len || data[i] == \'\\n\' || data[i] == \'\\r\') is_empty = 1;\n        if (!is_empty) {\n            if (!have_nonempty || indent < min_indent) min_indent = indent;\n            have_nonempty = 1;\n        }\n        while (i < len && data[i] != \'\\n\') { if (data[i] == \'\\r\') { i++; continue; } i++; }\n        if (i < len && data[i] == \'\\n\') i++;\n    }\n    if (!have_nonempty) min_indent = 0;\n\n    i = 0;\n    while (i < len) {\n        size_t indent = 0;\n        while (i < len && (data[i] == \' \' || data[i] == \'\\t\')) {\n            if (indent < min_indent) indent++;\n            i++;\n        }\n        while (i < len && data[i] != \'\\n\') { if (data[i] != \'\\r\') putchar(data[i]); i++; }\n        putchar(\'\\n\');\n        if (i < len && data[i] == \'\\n\') i++;\n    }\n}\n\n/* Wrapper to locate a marker and print the block as a fenced C code block. */\nstatic void print_marked_block_as_c(const char *sourceBuf, const char *markerId) {\n    String_View sv = read_source_code(sourceBuf, markerId);\n    printf("```c\\n");\n    if (sv.ok) {\n        print_sv_dedented_normalized(sv.data, sv.len);\n    } else {\n        printf("/* marker %s not found */\\n", markerId);\n    }\n    printf("```\\n\\n");\n}\n\n/* ---------------- utilities ---------------- */\n\nstatic const char *boolstr(int v) { return v ? "true" : "false"; }\n\nstatic void h2(const char *title) { printf("## %s\\n\\n", title); }\nstatic void h3(const char *title) { printf("### %s\\n\\n", title); }\nstatic void fence_begin(const char *lang) { printf("```%s\\n", lang ? lang : ""); }\nstatic void fence_end(void) { printf("```\\n\\n"); }\n\nstatic const char *cat_defined(void) { return "defined"; }\nstatic const char *cat_impldef(void) { return "implementation-defined"; }\nstatic const char *cat_unspecified(void) { return "unspecified"; }\nstatic const char *cat_extension(void) { return "extension"; }\n\n/* ---------------- 0. Report header ---------------- */\n\nstatic void sec_header_build_env(const char *sourceBuf) {\n    h2("0. Build and environment snapshot");\n\n    h3("Probe");\n    //#+begin_marker u5q3z8n1k2m\n    /*\n    Print compiler and language macros; discover pointer width; probe endianness later.\n    Floating model overview: FLT_RADIX and mantissa digits from <float.h>.\n    */\n    //#+end_marker u5q3z8n1k2m\n    print_marked_block_as_c(sourceBuf, "u5q3z8n1k2m");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "u5q3z8n1k2m");\n\n    h3("Compiler and language macros");\n    fence_begin("text");\n#if defined(__clang__)\n    printf("compiler: clang %d.%d.%d\\n", __clang_major__, __clang_minor__, __clang_patchlevel__);\n#elif defined(__GNUC__)\n    printf("compiler: gcc %d.%d.%d\\n", __GNUC__, __GNUC_MINOR__, __GNUC_PATCHLEVEL__);\n#elif defined(_MSC_VER)\n    printf("compiler: msvc %d\\n", (int)_MSC_VER);\n#else\n    printf("compiler: unknown\\n");\n#endif\n\n#if defined(__STDC__)\n    printf("__STDC__ = %ld\\n", (long)__STDC__);\n#else\n    printf("__STDC__ undefined\\n");\n#endif\n#if defined(__STDC_VERSION__)\n    printf("__STDC_VERSION__ = %ld\\n", (long)__STDC_VERSION__);\n#else\n    printf("__STDC_VERSION__ undefined\\n");\n#endif\n    fence_end();\n\n    h3("Target and pointer width");\n    fence_begin("text");\n#if defined(__x86_64__) || defined(_M_X64)\n    printf("arch: x86_64\\n");\n#elif defined(__i386__) || defined(_M_IX86)\n    printf("arch: x86\\n");\n#elif defined(__aarch64__)\n    printf("arch: aarch64\\n");\n#elif defined(__arm__)\n    printf("arch: arm\\n");\n#else\n    printf("arch: unknown\\n");\n#endif\n    printf("sizeof(void*) = %zu bytes\\n", sizeof(void*));\n    fence_end();\n\n    h3("Endianness probe");\n    //#+begin_marker gx2gk5s7l0z\n    /*\n    A simple, well-defined endianness probe:\n      - Store 0x01020304 in a 32-bit object.\n      - Read its representation via unsigned char*.\n      - Interpret the first byte: 0x04 => little-endian; 0x01 => big-endian.\n    */\n    //#+end_marker gx2gk5s7l0z\n    print_marked_block_as_c(sourceBuf, "gx2gk5s7l0z");\n\n    h3("Observed output");\n    fence_begin("text");\n    {\n        uint32_t v = 0x01020304u;\n        unsigned char *p = (unsigned char*)&v;\n        printf("bytes of 0x01020304: %u %u %u %u\\n", (unsigned)p[0], (unsigned)p[1], (unsigned)p[2], (unsigned)p[3]);\n        if (p[0] == 0x04) printf("endianness: little-endian (%s)\\n", cat_impldef());\n        else if (p[0] == 0x01) printf("endianness: big-endian (%s)\\n", cat_impldef());\n        else printf("endianness: unusual (%s)\\n", cat_impldef());\n    }\n    fence_end();\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "gx2gk5s7l0z");\n\n    h3("Floating model");\n    fence_begin("text");\n    printf("FLT_RADIX = %d\\n", FLT_RADIX);\n    printf("FLT_MANT_DIG = %d, DBL_MANT_DIG = %d, LDBL_MANT_DIG = %d\\n", FLT_MANT_DIG, DBL_MANT_DIG, LDBL_MANT_DIG);\n    printf("FLT_DIG = %d, DBL_DIG = %d, LDBL_DIG = %d\\n", FLT_DIG, DBL_DIG, LDBL_DIG);\n    fence_end();\n}\n\n/* ---------------- 1. Fundamental limits and properties ---------------- */\n\nstatic void sec_fundamental(const char *sourceBuf) {\n    h2("1. Fundamental limits and properties");\n\n    h3("Probe");\n    //#+begin_marker h9f2k7r1c3b\n    /*\n    Query integer limits from <limits.h> and floating limits from <float.h>.\n    Sanity-check: FLT_MIN < 1.0f.\n    Print sizeof(T) and approximate alignment via offsetof(struct{char c; T t;}, t).\n    */\n    //#+end_marker h9f2k7r1c3b\n    print_marked_block_as_c(sourceBuf, "h9f2k7r1c3b");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "h9f2k7r1c3b");\n\n    h3("Integer limits");\n    fence_begin("text");\n    printf("CHAR_BIT = %d\\n", CHAR_BIT);\n    printf("SCHAR_MIN = %d, SCHAR_MAX = %d\\n", SCHAR_MIN, SCHAR_MAX);\n    printf("UCHAR_MAX = %u\\n", UCHAR_MAX);\n    printf("CHAR_MIN = %d, CHAR_MAX = %d\\n", CHAR_MIN, CHAR_MAX);\n    printf("SHRT_MIN = %d, SHRT_MAX = %d, USHRT_MAX = %u\\n", SHRT_MIN, SHRT_MAX, USHRT_MAX);\n    printf("INT_MIN = %d, INT_MAX = %d, UINT_MAX = %u\\n", INT_MIN, INT_MAX, UINT_MAX);\n    printf("LONG_MIN = %ld, LONG_MAX = %ld, ULONG_MAX = %lu\\n", LONG_MIN, LONG_MAX, ULONG_MAX);\n    printf("LLONG_MIN = %lld, LLONG_MAX = %lld, ULLONG_MAX = %llu\\n",\n           (long long)LLONG_MIN, (long long)LLONG_MAX, (unsigned long long)ULLONG_MAX);\n    fence_end();\n\n    h3("Floating limits and relations");\n    fence_begin("text");\n    printf("FLT_MIN = %e < 1.0f => %s\\n", FLT_MIN, boolstr(FLT_MIN < 1.0f));\n    printf("DBL_MIN = %e < 1.0  => %s\\n", DBL_MIN, boolstr(DBL_MIN < 1.0));\n    printf("LDBL_MIN = %Le < 1.0L => %s\\n", LDBL_MIN, boolstr(LDBL_MIN < 1.0L));\n    fence_end();\n\n    h3("Sizes and alignment of fundamental types");\n    fence_begin("text");\n#define SZAL(T,name) do { \\\n    printf("%-18s sizeof=%zu align~= %zu\\n", name, sizeof(T), (size_t)offsetof(struct{char c; T t;}, t)); \\\n} while(0)\n    SZAL(char, "char");\n    SZAL(signed char, "signed char");\n    SZAL(unsigned char, "unsigned char");\n    SZAL(short, "short");\n    SZAL(unsigned short, "unsigned short");\n    SZAL(int, "int");\n    SZAL(unsigned, "unsigned");\n    SZAL(long, "long");\n    SZAL(unsigned long, "unsigned long");\n    SZAL(long long, "long long");\n    SZAL(unsigned long long, "unsigned long long");\n    SZAL(float, "float");\n    SZAL(double, "double");\n    SZAL(long double, "long double");\n    SZAL(void*, "void*");\n    SZAL(size_t, "size_t");\n    SZAL(ptrdiff_t, "ptrdiff_t");\n    SZAL(intptr_t, "intptr_t");\n    SZAL(uintptr_t, "uintptr_t");\n#undef SZAL\n    fence_end();\n}\n\n/* ---------------- 2. Literals and lexical behaviors ---------------- */\n\nstatic void sec_literals(const char *sourceBuf) {\n    h2("2. Literals and lexical behaviors");\n\n    h3("Probe: character and string literal basics");\n    //#+begin_marker d4m8y8o9c2f\n    /*\n    - Character literals have type int in C, not char. sizeof(\'A\') is sizeof(int).\n    - String literal concatenation happens at translation time: "hello" " " "world".\n    - Embedded NUL in string literals affects strlen but not sizeof array initialization.\n    */\n    //#+end_marker d4m8y8o9c2f\n    print_marked_block_as_c(sourceBuf, "d4m8y8o9c2f");\n\n    h3("Observed output");\n    fence_begin("text");\n    printf("\'A\' value=%d sizeof(\'A\')=%zu\\n", \'A\', sizeof(\'A\'));\n    printf("\'\\\\n\' value=%d\\n", \'\\n\');\n    printf("L\'A\' sizeof element=%zu\\n", sizeof(L\'A\'));\n    {\n        const char *s = "hello" " " "world";\n        printf("\\"hello\\" \\" \\" \\"world\\" => %s\\n", s);\n        const char t[] = "a\\0b";\n        printf("strlen(\\"a\\\\0b\\")=%zu, sizeof array=%zu\\n", strlen(t), sizeof t);\n    }\n    fence_end();\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "d4m8y8o9c2f");\n\n    h3("Integer literal types and bases");\n    fence_begin("c");\n    /*\n    Literal suffixes influence type selection:\n      - 42   => int (or wider) per usual integer constant rules.\n      - 42U  => unsigned int (or wider).\n      - 42L  => long.\n      - 0xFFFFFFFF without suffix may be unsigned int or unsigned long depending on width.\n    */\n    fence_end();\n    fence_begin("text");\n    printf("sizeof 42 = %zu\\n", sizeof 42);\n    printf("sizeof 42U = %zu\\n", sizeof 42U);\n    printf("sizeof 42L = %zu\\n", sizeof 42L);\n    printf("sizeof 0xFFFFFFFF = %zu (%s)\\n", sizeof 0xFFFFFFFF, cat_impldef());\n    printf("octal 077 => %d, hex 0x2A => %d\\n", 077, 0x2A);\n    fence_end();\n\n    h3("Floating literal suffixes");\n    fence_begin("text");\n    printf("sizeof 1.0 = %zu, sizeof 1.0f = %zu, sizeof 1.0L = %zu\\n", sizeof 1.0, sizeof 1.0f, sizeof 1.0L);\n    fence_end();\n\n    h3("Wide string basics");\n    fence_begin("text");\n    printf("sizeof L\\"abc\\" = %zu bytes, element size=%zu\\n", sizeof(L"abc"), sizeof(L"abc"[0]));\n    fence_end();\n}\n\n/* ---------------- 3. Type system highlights ---------------- */\n\nstatic void print_plain_char_signedness(void) {\n    signed char sc = -1;\n    char c = (char)sc;\n    printf("plain char is %s\\n", c == -1 ? "signed" : "unsigned");\n}\n\nstatic void takes_restrict(int n, int * restrict p, int * restrict q) {\n    for (int i = 0; i < n; ++i) { p[i] += q[i]; }\n}\n\nstatic void sec_type_system(const char *sourceBuf) {\n    h2("3. Type system highlights");\n\n    h3("Probe");\n    //#+begin_marker s8m1e0q9v4y\n    /*\n    - The signedness of plain \'char\' is implementation-defined.\n    - _Bool is a distinct type; values are 0 or 1 after conversion.\n    - Qualifiers like const/volatile do not change sizeof; \'restrict\' is a promise\n      about non-overlapping pointed-to objects that can enable better optimization.\n    */\n    //#+end_marker s8m1e0q9v4y\n    print_marked_block_as_c(sourceBuf, "s8m1e0q9v4y");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "s8m1e0q9v4y");\n\n    h3("Signedness of plain char");\n    fence_begin("text");\n    print_plain_char_signedness();\n    fence_end();\n\n    h3("_Bool and stdbool semantics");\n    fence_begin("text");\n    _Bool b = 2; /* any non-zero converts to 1 */\n    printf("_Bool b = 2 => stored as %d; !b = %d\\n", (int)b, (int)!b);\n    fence_end();\n\n    h3("Qualifiers and restrict");\n    fence_begin("c");\n    //#+begin_marker 2lxaq9m3y7p\n    /*\n    \'restrict\' qualifier on pointers promises that, for the lifetime of the pointers,\n    only they (or values derived from them) will be used to access the pointed-to objects.\n    This permits aliasing optimizations. It does not change the pointer\'s size or representation.\n    */\n    //#+end_marker 2lxaq9m3y7p\n    fence_end();\n    h3("Observed output");\n    fence_begin("text");\n    {\n        int a[3] = {1,2,3}, b[3] = {10,20,30};\n        takes_restrict(3, a, b);\n        printf("after takes_restrict: a = {%d,%d,%d}\\n", a[0], a[1], a[2]);\n        printf("sizeof(int* restrict) == sizeof(int*) => %zu == %zu\\n", sizeof(int* restrict), sizeof(int*));\n    }\n    fence_end();\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "2lxaq9m3y7p");\n}\n\n/* ---------------- 4. sizeof and alignment micro-experiments ---------------- */\n\nstatic void sec_sizeof_alignment(const char *sourceBuf) {\n    h2("4. sizeof and alignment micro-experiments");\n\n    h3("Probe");\n    //#+begin_marker q4w7e2t9u6p\n    /*\n    Demonstrate sizeof for scalars, pointers, arrays, VLAs, structs, unions,\n    and a host struct with a flexible array member (FAM).\n    Alignment approximated via offsetof(struct{char c; T t;}, t).\n    */\n    //#+end_marker q4w7e2t9u6p\n    print_marked_block_as_c(sourceBuf, "q4w7e2t9u6p");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "q4w7e2t9u6p");\n\n    h3("Scalars");\n    fence_begin("text");\n#define P(T,name) printf("%-18s sizeof=%zu align~= %zu\\n", name, sizeof(T), (size_t)offsetof(struct{char c; T t;}, t))\n    P(char,"char"); P(short,"short"); P(int,"int"); P(long,"long");\n    P(float,"float"); P(double,"double"); P(long double,"long double");\n#undef P\n    fence_end();\n\n    h3("Pointers and function pointers");\n    fence_begin("text");\n    typedef int (*fp)(int);\n    printf("sizeof(int*)=%zu, sizeof(double*)=%zu, sizeof(fp)=%zu\\n", sizeof(int*), sizeof(double*), sizeof(fp));\n    fence_end();\n\n    h3("Fixed arrays");\n    fence_begin("text");\n    {\n        char a1[3]; int a2[3]; double a3[3]; (void)a1; (void)a2; (void)a3;\n        //#+begin_marker 7ovooikyhk8\n        {\n            const char *decl = "char a[3]";\n            printf("%-23s  %8zu     %7zu  %5d  elem size * count\\n",\n                   decl, sizeof a1, sizeof a1[0], 3);\n        }\n        {\n            const char *decl = "int a[3]";\n            printf("%-23s  %8zu     %7zu  %5d  elem size * count\\n",\n                   decl, sizeof a2, sizeof a2[0], 3);\n        }\n        {\n            const char *decl = "double a[3]";\n            printf("%-23s  %8zu     %7zu  %5d  elem size * count\\n",\n                   decl, sizeof a3, sizeof a3[0], 3);\n        }\n        //#+end_marker 7ovooikyhk8\n    }\n    fence_end();\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "7ovooikyhk8");\n\n    h3("VLA at runtime");\n    fence_begin("text");\n    {\n        int n = 7; int vla[n]; (void)vla;\n        printf("n=%d, sizeof vla = %zu (expect n*sizeof(int)=%zu)\\n", n, sizeof vla, (size_t)n*sizeof(int));\n    }\n    fence_end();\n\n    h3("Structs and unions, flexible array host");\n    fence_begin("text");\n    struct A { char c; int i; };\n    struct B { char c; double d; int i; };\n    union U { int i; double d; char c; };\n    struct Flex { size_t n; int data[]; };\n    printf("struct A sizeof=%zu sum(fields)=%zu align~= %zu offsets: c=%zu i=%zu\\n",\n        sizeof(struct A), sizeof(char)+sizeof(int), (size_t)offsetof(struct{char c; struct A t;}, t),\n        (size_t)offsetof(struct A,c), (size_t)offsetof(struct A,i));\n    printf("struct B sizeof=%zu sum(fields)=%zu align~= %zu offsets: c=%zu d=%zu i=%zu\\n",\n        sizeof(struct B), sizeof(char)+sizeof(double)+sizeof(int), (size_t)offsetof(struct{char c; struct B t;}, t),\n        (size_t)offsetof(struct B,c), (size_t)offsetof(struct B,d), (size_t)offsetof(struct B,i));\n    printf("union U sizeof=%zu align~= %zu max(member sizes)=%zu\\n",\n        sizeof(union U), (size_t)offsetof(struct{char c; union U t;}, t),\n        (sizeof(double)>sizeof(int)?sizeof(double):sizeof(int)));\n    printf("struct Flex host sizeof=%zu (FAM contributes 0)\\n", sizeof(struct Flex));\n    fence_end();\n}\n\n/* ---------------- 5. Struct layout, padding, flexible arrays ---------------- */\n\nstatic void sec_structs_flex(const char *sourceBuf) {\n    h2("5. Struct layout, padding, and flexible arrays");\n\n    h3("Probe");\n    //#+begin_marker n3b7k2h9p5x\n    /*\n    Use offsetof to reveal padding. Compare assignment equality by fields, not memcmp.\n    Bit-fields: widths and signedness are implementation-defined.\n    Flexible array member: allocate sizeof(header)+n*sizeof(elem) and access payload.\n    */\n    //#+end_marker n3b7k2h9p5x\n    print_marked_block_as_c(sourceBuf, "n3b7k2h9p5x");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "n3b7k2h9p5x");\n\n    h3("offsetof and padding gaps");\n    fence_begin("text");\n    struct P { char c; int i; double d; };\n    size_t sum = sizeof(char)+sizeof(int)+sizeof(double);\n    printf("struct P sizeof=%zu fields sum=%zu offsets: c=%zu i=%zu d=%zu\\n",\n           sizeof(struct P), sum,\n           (size_t)offsetof(struct P,c), (size_t)offsetof(struct P,i), (size_t)offsetof(struct P,d));\n    fence_end();\n\n    h3("Copy, assign, and equality");\n    fence_begin("text");\n    struct Q { int x; double y; };\n    struct Q q1 = (struct Q){1, 2.0}, q2 = q1;\n    int equal = (q1.x == q2.x) && (q1.y == q2.y);\n    printf("struct assignment copies fields; equal by fields => %s\\n", boolstr(equal));\n    fence_end();\n\n    h3("Bit-fields packing and signedness");\n    fence_begin("text");\n    struct BF { unsigned a:3; signed b:5; unsigned c:6; };\n    struct BF bf = (struct BF){ 7u, -3, 0x2A };\n    unsigned packed = 0;\n    memcpy(&packed, &bf, sizeof bf < sizeof packed ? sizeof bf : sizeof packed);\n    printf("BF sizeof=%zu, a=%u, b=%d, c=%u, first bytes 0x%08x (%s)\\n",\n           sizeof bf, bf.a, bf.b, bf.c, packed, cat_impldef());\n    fence_end();\n\n    h3("Flexible array idiom allocation");\n    fence_begin("text");\n    struct Flex { size_t n; int data[]; };\n    size_t k = 5;\n    size_t bytes = sizeof(struct Flex) + k*sizeof(int);\n    struct Flex *fp = (struct Flex*)malloc(bytes);\n    if (fp) {\n        fp->n = k;\n        for (size_t i=0;i<k;i++) fp->data[i] = (int)i*i;\n        printf("malloc(%zu) ok; usable ints=%zu; last=%d\\n", bytes, fp->n, fp->data[k-1]);\n        free(fp);\n    } else {\n        printf("malloc failed\\n");\n    }\n    fence_end();\n}\n\n/* ---------------- 6. Unions and aliasing observations ---------------- */\n\nstatic void sec_unions_aliasing(const char *sourceBuf) {\n    h2("6. Unions and aliasing observations");\n\n    h3("Probe");\n    //#+begin_marker v6t1r9p3c0d\n    /*\n    Reading a different union member than the one most recently written is\n    implementation-defined; we use it only to illustrate overlapping representation.\n    For non-integer bit patterns, use memcpy to a same-sized integer type.\n    */\n    //#+end_marker v6t1r9p3c0d\n    print_marked_block_as_c(sourceBuf, "v6t1r9p3c0d");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "v6t1r9p3c0d");\n\n    h3("Active member and overlap illustration");\n    fence_begin("text");\n    union U { uint32_t u; unsigned char b[4]; };\n    union U u; u.u = 0x41424344u;\n    printf("write u.u=0x41424344 then read bytes: %u %u %u %u (%s)\\n",\n        (unsigned)u.b[0], (unsigned)u.b[1], (unsigned)u.b[2], (unsigned)u.b[3], cat_impldef());\n    fence_end();\n\n    h3("Representations via memcpy, avoiding aliasing UB");\n    fence_begin("text");\n    {\n        double d = 1.5;\n        uint64_t bits = 0;\n        memcpy(&bits, &d, sizeof bits);\n        printf("double 1.5 bit pattern = 0x%016" PRIx64 "\\n", (unsigned long long)bits);\n    }\n    fence_end();\n\n    h3("Common initial sequence");\n    fence_begin("text");\n    {\n        struct S1 { int tag; double x; };\n        struct S2 { int tag; int y; };\n        union US { struct S1 s1; struct S2 s2; };\n        union US us = { .s1 = { 7, 3.14 } };\n        printf("common initial tag=%d\\n", us.s2.tag);\n    }\n    fence_end();\n}\n\n/* ---------------- 7. Expressions and conversions ---------------- */\n\nstatic void sec_expr_conv(const char *sourceBuf) {\n    h2("7. Expressions and conversions");\n\n    h3("Probe");\n    //#+begin_marker m5z2x8c1v7k\n    /*\n    - Integer promotions: smaller integer types promote to int in expressions.\n    - Usual arithmetic conversions: mixing signed and unsigned can convert to unsigned.\n    - Variadic calls apply default promotions: float -> double, char/short -> int.\n    - Division and modulo with negatives truncate toward zero per C99.\n    - Ternary operator chooses a common type via usual arithmetic conversions.\n    */\n    //#+end_marker m5z2x8c1v7k\n    print_marked_block_as_c(sourceBuf, "m5z2x8c1v7k");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "m5z2x8c1v7k");\n\n    h3("Integer promotions");\n    fence_begin("text");\n    {\n        char c = 1; short s = 2;\n        printf("sizeof(c+s) => %zu (promotes to int)\\n", sizeof(c+s));\n    }\n    fence_end();\n\n    h3("Usual arithmetic conversions");\n    fence_begin("text");\n    {\n        unsigned u = 1; int i = -2;\n        unsigned r = u + i; /* converted to unsigned of that rank */\n        printf("u=1 (unsigned), i=-2 (int), u+i as unsigned => %u (%s)\\n", r, cat_impldef());\n    }\n    fence_end();\n\n    h3("Floating promotions in variadics");\n    fence_begin("text");\n    {\n        float f = 1.25f;\n        printf("printf %%f receives double, float promoted: %f\\n", f);\n    }\n    fence_end();\n\n    h3("Conversions and negatives");\n    fence_begin("text");\n    {\n        double x = 3.9; int xi = (int)x;\n        int a = -7, b = 3;\n        printf("(int)3.9 = %d (trunc toward zero)\\n", xi);\n        printf("-7 / 3 = %d, -7 %% 3 = %d\\n", a/b, a%b);\n    }\n    fence_end();\n\n    h3("Ternary operator type resolution");\n    fence_begin("text");\n    {\n        printf("sizeof( (1? 1 : 1.0) ) = %zu (to double)\\n", sizeof(1?1:1.0));\n        printf("sizeof( (1? -1 : 1u) ) = %zu (%s)\\n", sizeof(1?-1:1u), cat_impldef());\n    }\n    fence_end();\n}\n\n/* ---------------- 8. Operators, evaluation, sequencing ---------------- */\n\nstatic int side_counter;\n\nstatic int side_effect(int *p) { (*p)++; return 1; }\n\nstatic void sec_operators_eval(const char *sourceBuf) {\n    h2("8. Operators, evaluation, and sequencing");\n\n    h3("Probe");\n    //#+begin_marker k9p1l3o7i2u\n    /*\n    Show only well-defined uses:\n      - Post-increment used once in an expression.\n      - Short-circuiting prevents evaluation of the right operand when not needed.\n      - Right shift of negative signed integers is implementation-defined.\n      - sizeof does not evaluate its operand.\n    */\n    //#+end_marker k9p1l3o7i2u\n    print_marked_block_as_c(sourceBuf, "k9p1l3o7i2u");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "k9p1l3o7i2u");\n\n    h3("Pre and post increment in sequenced contexts");\n    fence_begin("text");\n    {\n        int x=1; int y = x++ + 2;\n        printf("x=1; y = x++ + 2 => y=%d x=%d\\n", y, x);\n    }\n    fence_end();\n\n    h3("Short-circuiting");\n    fence_begin("text");\n    {\n        side_counter = 0;\n        int v = 0 && side_effect(&side_counter);\n        printf("0 && side_effect => v=%d, counter=%d (rhs not evaluated)\\n", v, side_counter);\n        side_counter = 0;\n        v = 1 || side_effect(&side_counter);\n        printf("1 || side_effect => v=%d, counter=%d (rhs not evaluated)\\n", v, side_counter);\n    }\n    fence_end();\n\n    h3("Bit shifts");\n    fence_begin("text");\n    {\n        unsigned u = 1u;\n        printf("unsigned right shift: (1u<<3)>>1 = %u\\n", (u<<3)>>1);\n        int si = -4;\n        printf("signed right shift of negative is %s; example (-4>>1)=%d\\n", cat_impldef(), (si>>1));\n    }\n    fence_end();\n\n    h3("sizeof on expressions is unevaluated");\n    fence_begin("text");\n    {\n        int t = 0;\n        sizeof(t++); /* not evaluated */\n        printf("after sizeof(t++), t=%d (no increment)\\n", t);\n    }\n    fence_end();\n}\n\n/* ---------------- 9. Control flow probes ---------------- */\n\nstatic void sec_control_flow(const char *sourceBuf) {\n    h2("9. Control flow probes");\n\n    h3("Probe");\n    //#+begin_marker b2n8m4v6c1q\n    /*\n    Count iterations for for/while/do-while to show entry semantics.\n    Demonstrate switch fallthrough and nested-loop break/continue effects.\n    */\n    //#+end_marker b2n8m4v6c1q\n    print_marked_block_as_c(sourceBuf, "b2n8m4v6c1q");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "b2n8m4v6c1q");\n\n    h3("for, while, do-while");\n    fence_begin("text");\n    {\n        int c1=0,c2=0,c3=0;\n        for (int i=0;i<3;i++) c1++;\n        int i=0; while (i<3) { c2++; i++; }\n        i=0; do { c3++; i++; } while (i<3);\n        printf("for=%d while=%d do-while=%d\\n", c1,c2,c3);\n    }\n    fence_end();\n\n    h3("switch and fallthrough");\n    fence_begin("text");\n    {\n        int x=2, s=0;\n        switch (x) {\n            case 1: s+=1;\n            case 2: s+=2; /* fallthrough intentional */\n            default: s+=4;\n        }\n        printf("x=2, fallthrough sum=%d\\n", s);\n    }\n    fence_end();\n\n    h3("break and continue in nested loops");\n    fence_begin("text");\n    {\n        int outer=0, inner=0;\n        for (int i=0;i<3;i++) {\n            outer++;\n            for (int j=0;j<3;j++) {\n                if (j==1) continue;\n                inner++;\n                if (i==1 && j==2) break;\n            }\n        }\n        printf("outer=%d inner=%d\\n", outer, inner);\n    }\n    fence_end();\n}\n\n/* ---------------- 10. Storage duration and initialization ---------------- */\n\nstatic int external_var; /* external linkage in this TU */\n\nstatic int static_once(void) {\n    static int counter = 0;\n    counter++;\n    return counter;\n}\n\nstatic int *safe_copy_from_stack(void) {\n    int local = 42;\n    int *ret = (int*)malloc(sizeof(int));\n    if (ret) *ret = local; /* copy value, not pointer to local */\n    return ret;\n}\n\nstatic void sec_storage_init(const char *sourceBuf) {\n    h2("10. Storage duration and initialization");\n\n    h3("Probe");\n    //#+begin_marker y7h3j9k1l0p\n    /*\n    - Static locals initialize once and retain value between calls.\n    - Static-duration objects without explicit initializers are zero-initialized.\n    - External linkage variable exists once per program.\n    - Do not return pointer to a local; copy needed value to dynamic storage instead.\n    */\n    //#+end_marker y7h3j9k1l0p\n    print_marked_block_as_c(sourceBuf, "y7h3j9k1l0p");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "y7h3j9k1l0p");\n\n    h3("Static local initialization once");\n    fence_begin("text");\n    printf("static_once() calls: %d %d %d\\n", static_once(), static_once(), static_once());\n    fence_end();\n\n    h3("Static-duration zero initialization");\n    fence_begin("text");\n    static int uninit_static;\n    printf("uninitialized static int = %d\\n", uninit_static);\n    fence_end();\n\n    h3("Linkage note");\n    fence_begin("text");\n    printf("external_var has external linkage in this translation unit; value=%d\\n", external_var);\n    fence_end();\n\n    h3("Lifetime boundaries and safe copy");\n    fence_begin("text");\n    int *p = safe_copy_from_stack();\n    if (p) { printf("copied value from dead frame = %d\\n", *p); free(p); }\n    fence_end();\n}\n\n/* ---------------- 11. Arrays, pointers, decay rules ---------------- */\n\nstatic void takes_array_param(int a[], size_t n) {\n    printf("in function: parameter sizeof(a)=%zu (pointer), n=%zu\\n", sizeof a, n);\n}\n\nstatic void sec_arrays_pointers(const char *sourceBuf) {\n    h2("11. Arrays, pointers, and decay rules");\n\n    h3("Probe");\n    //#+begin_marker t8g2f9d1s6a\n    /*\n    - Arrays decay to pointers in most expressions (including function calls).\n    - Pointer arithmetic scales by sizeof(element); measure deltas within same array.\n    - 2D arrays are row-major (rows contiguous).\n    - VLAs have runtime size; sizeof(VLA) reflects runtime element count.\n    - strlen stops at first NUL; sizeof(array) is full byte count.\n    */\n    //#+end_marker t8g2f9d1s6a\n    print_marked_block_as_c(sourceBuf, "t8g2f9d1s6a");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "t8g2f9d1s6a");\n\n    h3("Array to pointer decay");\n    fence_begin("text");\n    int a[4] = {1,2,3,4};\n    printf("in scope: sizeof(a)=%zu\\n", sizeof a);\n    takes_array_param(a, 4);\n    fence_end();\n\n    h3("Pointer arithmetic scale factor");\n    fence_begin("text");\n    {\n        int ai[2]; double ad[2];\n        ptrdiff_t di = (char*)&ai[1] - (char*)&ai[0];\n        ptrdiff_t dd = (char*)&ad[1] - (char*)&ad[0];\n        printf("delta(&ai[1]-&ai[0])=%td bytes, delta(&ad[1]-&ad[0])=%td bytes\\n", di, dd);\n    }\n    fence_end();\n\n    h3("1D and 2D row-major layout");\n    fence_begin("text");\n    {\n        int m[2][3] = {{1,2,3},{4,5,6}};\n        printf("&m[0][0]=%p, &m[0][1]=%p, &m[1][0]=%p (row-major contiguous)\\n",\n               (void*)&m[0][0], (void*)&m[0][1], (void*)&m[1][0]);\n    }\n    fence_end();\n\n    h3("VLA pass-through");\n    fence_begin("text");\n    {\n        int n=5; int v[n]; v[0]=42;\n        printf("VLA n=%d, sizeof v = %zu, first=%d\\n", n, sizeof v, v[0]);\n    }\n    fence_end();\n\n    h3("strlen vs sizeof for strings");\n    fence_begin("text");\n    {\n        char s1[5] = "abc";\n        char s2[5] = {\'a\',\'\\0\',\'x\',\'y\',\'z\'};\n        printf("s1: strlen=%zu sizeof=%zu; s2: strlen=%zu sizeof=%zu\\n",\n               strlen(s1), sizeof s1, strlen(s2), sizeof s2);\n    }\n    fence_end();\n}\n\n/* ---------------- 12. Functions and calling patterns ---------------- */\n\nstatic int square_fn(int x) { return x*x; }\nstatic int cube_fn(int x) { return x*x*x; }\n\nstatic inline int add_inline(int a, int b) { return a+b; }\n\nstatic int sum_variadic(int count, ...) {\n    va_list ap; va_start(ap, count);\n    long long acc = 0;\n    for (int i=0;i<count;i++) {\n        acc += va_arg(ap, int); /* default promotions: char, short promoted to int */\n    }\n    va_end(ap);\n    return (int)acc;\n}\n\nstatic void sec_functions_calls(const char *sourceBuf) {\n    h2("12. Functions and calling patterns");\n\n    h3("Probe");\n    //#+begin_marker r1c6v8b3n5m\n    /*\n    - Function pointers: take address and call through pointer.\n    - static inline functions work within a single translation unit (C99).\n    - Variadic functions: default promotions apply; printf returns chars written.\n    */\n    //#+end_marker r1c6v8b3n5m\n    print_marked_block_as_c(sourceBuf, "r1c6v8b3n5m");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "r1c6v8b3n5m");\n\n    h3("Function pointers");\n    fence_begin("text");\n    {\n        int (*fp)(int) = square_fn;\n        printf("square_fn(5) via pointer = %d, cube_fn(3) = %d\\n", fp(5), cube_fn(3));\n        printf("sizeof(function pointer)=%zu vs sizeof(void*)=%zu\\n", sizeof fp, sizeof(void*));\n    }\n    fence_end();\n\n    h3("Inline functions in one TU");\n    fence_begin("text");\n    printf("add_inline(2,3) = %d\\n", add_inline(2,3));\n    fence_end();\n\n    h3("Variadic function and default promotions");\n    fence_begin("text");\n    {\n        char a=1; short b=2; int c=3;\n        printf("sum_variadic(a,b,c) = %d\\n", sum_variadic(3, a, b, c));\n        int n = printf("printf returns chars written: hello => ");\n        printf("%d + 6\\n", n);\n    }\n    fence_end();\n}\n\n/* ---------------- 13. qsort and bsearch ---------------- */\n\nstruct Rec { int key; int tag; };\n\nstatic int cmp_int(const void *a, const void *b) {\n    int ia = *(const int*)a, ib = *(const int*)b;\n    return (ia>ib) - (ia<ib);\n}\n\nstatic int cmp_rec_by_key(const void *a, const void *b) {\n    const struct Rec *ra = (const struct Rec*)a, *rb = (const struct Rec*)b;\n    if (ra->key < rb->key) return -1;\n    if (ra->key > rb->key) return 1;\n    return (ra->tag > rb->tag) - (ra->tag < rb->tag); /* induce instability check */\n}\n\nstatic void sec_qsort_bsearch(const char *sourceBuf) {\n    h2("13. qsort and bsearch on arrays");\n\n    h3("Probe");\n    //#+begin_marker p0l9k3j7h2g\n    /*\n    qsort requires a strict weak ordering comparator; it is not stable.\n    bsearch requires the array to be sorted by the same comparator.\n    */\n    //#+end_marker p0l9k3j7h2g\n    print_marked_block_as_c(sourceBuf, "p0l9k3j7h2g");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "p0l9k3j7h2g");\n\n    h3("qsort of ints and instability note");\n    fence_begin("text");\n    {\n        int a[8] = {5,1,4,2,8,0,2,5};\n        qsort(a, 8, sizeof a[0], cmp_int);\n        printf("sorted ints: ");\n        for (int i=0;i<8;i++) printf("%d%s", a[i], i+1<8?" ":"");\n        printf("\\n");\n        struct Rec r[4] = {{1,1},{1,2},{2,1},{2,2}};\n        qsort(r, 4, sizeof r[0], cmp_rec_by_key);\n        printf("records after qsort by key: ");\n        for (int i=0;i<4;i++) printf("{k=%d,t=%d}%s", r[i].key, r[i].tag, i+1<4?" ":"");\n        printf(" (order of equal keys is %s)\\n", "unspecified");\n    }\n    fence_end();\n\n    h3("bsearch success and failure");\n    fence_begin("text");\n    {\n        int a[6] = {0,2,4,6,8,10};\n        int key = 6;\n        int *found = (int*)bsearch(&key, a, 6, sizeof a[0], cmp_int);\n        printf("bsearch 6 => %s\\n", found ? "found" : "not found");\n        key = 7;\n        found = (int*)bsearch(&key, a, 6, sizeof a[0], cmp_int);\n        printf("bsearch 7 => %s\\n", found ? "found" : "not found");\n    }\n    fence_end();\n}\n\n/* ---------------- 14. Time basics ---------------- */\n\nstatic void sec_time_basics(const char *sourceBuf) {\n    h2("14. Time basics");\n\n    h3("Probe");\n    //#+begin_marker z4x1c7v2b9n\n    /*\n    time() returns epoch seconds; localtime/gmtime convert to broken-down time; strftime formats.\n    clock() measures CPU time used by the process; divide ticks by CLOCKS_PER_SEC.\n    difftime gives a double difference between two time_t values.\n    */\n    //#+end_marker z4x1c7v2b9n\n    print_marked_block_as_c(sourceBuf, "z4x1c7v2b9n");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "z4x1c7v2b9n");\n\n    h3("time and localtime/gmtime");\n    fence_begin("text");\n    time_t now = time(NULL);\n    printf("time() = %ld\\n", (long)now);\n    struct tm lt = *localtime(&now);\n    struct tm gt = *gmtime(&now);\n    char buf[64];\n    strftime(buf, sizeof buf, "%Y-%m-%d %H:%M:%S", &lt);\n    printf("localtime: %s\\n", buf);\n    strftime(buf, sizeof buf, "%Y-%m-%d %H:%M:%S", &gt);\n    printf("gmtime:   %s\\n", buf);\n    fence_end();\n\n    h3("clock and difftime");\n    fence_begin("text");\n    clock_t c0 = clock();\n    volatile double acc = 0.0;\n    for (int i=0;i<500000;i++) acc += sin((double)i*0.000001);\n    clock_t c1 = clock();\n    printf("clock dt = %.6f seconds\\n", (double)(c1-c0)/CLOCKS_PER_SEC);\n    time_t t0 = now, t1 = now + 3;\n    printf("difftime(now+3, now) = %.0f\\n", difftime(t1,t0));\n    fence_end();\n}\n\n/* ---------------- 15. Memory management and object lifetime ---------------- */\n\nstatic void sec_memory(const char *sourceBuf) {\n    h2("15. Memory management and object lifetime");\n\n    h3("Probe");\n    //#+begin_marker c3v9b1n7m4k\n    /*\n    - malloc alignment suffices for any object type.\n    - calloc zeroes memory; malloc leaves indeterminate bytes.\n    - realloc may move or keep the same pointer; content preserved up to min(old,new).\n    - memmove handles overlap; memcpy requires non-overlapping regions.\n    - memset sets bytes; resulting int value from nonzero patterns is implementation-defined.\n    */\n    //#+end_marker c3v9b1n7m4k\n    print_marked_block_as_c(sourceBuf, "c3v9b1n7m4k");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "c3v9b1n7m4k");\n\n    h3("malloc alignment");\n    fence_begin("text");\n    {\n        void *p = malloc(64);\n        if (p) {\n            printf("malloc ptr %% alignment 8 = %zu\\n", ((size_t)(uintptr_t)p) % 8);\n            free(p);\n        }\n    }\n    fence_end();\n\n    h3("calloc zero-initialization vs malloc");\n    fence_begin("text");\n    {\n        unsigned char *m = (unsigned char*)malloc(8);\n        unsigned char *c = (unsigned char*)calloc(8,1);\n        if (m && c) {\n            printf("malloc first 8 bytes: ");\n            for (int i=0;i<8;i++) printf("%02x%s", m[i], i+1<8?" ":"");\n            printf("\\n");\n            printf("calloc first 8 bytes: ");\n            for (int i=0;i<8;i++) printf("%02x%s", c[i], i+1<8?" ":"");\n            printf("\\n");\n        }\n        free(m); free(c);\n    }\n    fence_end();\n\n    h3("realloc growth and shrink");\n    fence_begin("text");\n    {\n        size_t n=4;\n        int *p = (int*)malloc(n*sizeof(int));\n        if (p) {\n            for (size_t i=0;i<n;i++) p[i]=(int)i;\n            void *old=p;\n            p = (int*)realloc(p, 8*sizeof(int));\n            printf("realloc grow: moved=%s\\n", (void*)p==old?"no":"maybe");\n            p = (int*)realloc(p, 2*sizeof(int));\n            printf("realloc shrink ok\\n");\n            free(p);\n        }\n    }\n    fence_end();\n\n    h3("memmove vs memcpy with overlap");\n    fence_begin("text");\n    {\n        char s1[] = "abcdef";\n        memmove(s1+2, s1, 4);\n        printf("memmove overlap: %s\\n", s1);\n        printf("memcpy overlap: not executed to avoid UB; use memmove instead\\n");\n    }\n    fence_end();\n\n    h3("memset on non-char objects");\n    fence_begin("text");\n    {\n        int x = 0;\n        memset(&x, 0xFF, sizeof x);\n        printf("memset int with 0xFF yields pattern, x=%d (%s)\\n", x, cat_impldef());\n        x = 0;\n        memset(&x, 0x01, sizeof x);\n        printf("memset int with 0x01 yields pattern, x=%d (%s)\\n", x, cat_impldef());\n    }\n    fence_end();\n}\n\n/* ---------------- 16. Strings and byte operations ---------------- */\n\nstatic void sec_strings_bytes(const char *sourceBuf) {\n    h2("16. Strings and byte operations");\n\n    h3("Probe");\n    //#+begin_marker f2d7s9a1g6t\n    /*\n    - strlen stops at the first NUL.\n    - strcpy copies including the terminating NUL; strncpy may omit the NUL when truncated.\n    - strcat appends (check capacity first).\n    - strchr/strrchr/strstr return pointers; print offsets via pointer subtraction.\n    - strtok is stateful and not re-entrant.\n    */\n    //#+end_marker f2d7s9a1g6t\n    print_marked_block_as_c(sourceBuf, "f2d7s9a1g6t");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "f2d7s9a1g6t");\n\n    h3("strlen with embedded NUL");\n    fence_begin("text");\n    {\n        char s[] = {\'a\',\'b\',\'\\0\',\'c\'};\n        printf("strlen on {\'a\',\'b\',\'\\\\0\',\'c\'} => %zu\\n", strlen(s));\n    }\n    fence_end();\n\n    h3("strcpy and strncpy");\n    fence_begin("text");\n    {\n        char dst1[4]; char dst2[4];\n        strcpy(dst1, "abc");\n        strncpy(dst2, "abcd", sizeof dst2); /* no NUL if source len >= size */\n        dst2[sizeof dst2 - 1] = \'\\0\'; /* fix */\n        printf("strcpy dst1=\\"%s\\"; strncpy fixed dst2=\\"%s\\"\\n", dst1, dst2);\n    }\n    fence_end();\n\n    h3("strcat with capacity check");\n    fence_begin("text");\n    {\n        char buf[8] = "ab";\n        size_t cap = sizeof buf;\n        size_t len = strlen(buf);\n        const char *add = "cdef";\n        if (len + strlen(add) + 1 <= cap) strcat(buf, add);\n        printf("after safe strcat => \\"%s\\"\\n", buf);\n    }\n    fence_end();\n\n    h3("strchr, strrchr, strstr offsets");\n    fence_begin("text");\n    {\n        const char *s = "abracadabra";\n        const char *p1 = strchr(s, \'a\');\n        const char *p2 = strrchr(s, \'a\');\n        const char *p3 = strstr(s, "cad");\n        printf("first a at %td, last a at %td, \\"cad\\" at %td\\n",\n               p1? (ptrdiff_t)(p1-s):-1, p2? (ptrdiff_t)(p2-s):-1, p3? (ptrdiff_t)(p3-s):-1);\n    }\n    fence_end();\n\n    h3("strtok statefulness");\n    fence_begin("text");\n    {\n        char buf[] = "a,b,,c";\n        char *tok = strtok(buf, ",");\n        while (tok) { printf("[%s] ", tok); tok = strtok(NULL, ","); }\n        printf("\\n");\n    }\n    fence_end();\n}\n\n/* ---------------- 17. Character classification and case conversion ---------------- */\n\nstatic void sec_ctype_case(const char *sourceBuf) {\n    h2("17. Character classification and case conversion");\n\n    h3("Probe");\n    //#+begin_marker u5i9o3p1l7k\n    /*\n    ctype functions require inputs representable as unsigned char or EOF.\n    Passing negative char values is undefined behavior; cast to unsigned char.\n    We print a small table and demonstrate the signed-char trap.\n    */\n    //#+end_marker u5i9o3p1l7k\n    print_marked_block_as_c(sourceBuf, "u5i9o3p1l7k");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "u5i9o3p1l7k");\n\n    h3("Classification table");\n    fence_begin("text");\n    {\n        const char *s = "A1 \\t!";\n        for (const char *p=s; *p; ++p) {\n            unsigned char uc = (unsigned char)*p;\n            printf("\'%c\': isalpha=%d isdigit=%d isspace=%d\\n", *p, isalpha(uc)!=0, isdigit(uc)!=0, isspace(uc)!=0);\n        }\n    }\n    fence_end();\n\n    h3("Signed char trap");\n    fence_begin("text");\n    {\n        char c = (char)0xFF;\n        printf("isalpha((char)0xFF) => %d, isalpha((unsigned char)0xFF) => %d\\n",\n               isalpha(c), isalpha((unsigned char)c));\n    }\n    fence_end();\n\n    h3("toupper and tolower");\n    fence_begin("text");\n    {\n        unsigned char ch = \'a\';\n        printf("toupper(\'a\')=%c, tolower(\'Z\')=%c\\n", toupper(ch), tolower(\'Z\'));\n    }\n    fence_end();\n}\n\n/* ---------------- 18. Math library and special values ---------------- */\n\nstatic void sec_math_special(const char *sourceBuf) {\n    h2("18. Math library and special values");\n\n    h3("Probe");\n    //#+begin_marker h8j2k6l1m9n\n    /*\n    - NaN propagates through arithmetic; classify with isnan/isfinite.\n    - Floating division by zero yields +/-inf (int division by zero is undefined).\n    - Repeated addition of 0.1 shows rounding error in binary floating point.\n    - hypot(x,y) handles large arguments more robustly than sqrt(x*x+y*y).\n    */\n    //#+end_marker h8j2k6l1m9n\n    print_marked_block_as_c(sourceBuf, "h8j2k6l1m9n");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "h8j2k6l1m9n");\n\n    h3("NaN propagation and finiteness");\n    fence_begin("text");\n    {\n        double z = NAN;\n        printf("NAN + 1 => isnan=%d, isfinite=%d\\n", isnan(z+1.0)!=0, isfinite(z+1.0)!=0);\n    }\n    fence_end();\n\n    h3("Division by zero behavior");\n    fence_begin("text");\n    {\n        double v = 1.0/0.0;\n        printf("1.0/0.0 => %s, sign=%s\\n", isinf(v)?"inf":"other", v>0?"plus":"minus");\n    }\n    fence_end();\n\n    h3("Rounding illustration");\n    fence_begin("text");\n    {\n        double s=0.0; for (int i=0;i<10;i++) s+=0.1;\n        printf("sum of 0.1 ten times = %.20f, difference vs 1.0 = %.20f\\n", s, s-1.0);\n    }\n    fence_end();\n\n    h3("hypot vs sqrt(x*x+y*y)");\n    fence_begin("text");\n    {\n        double x=1e200, y=1e200;\n        double h=hypot(x,y);\n        double naive = sqrt(x*x + y*y);\n        printf("hypot=%.3e, sqrt-sum=%.3e\\n", h, naive);\n    }\n    fence_end();\n}\n\n/* ---------------- 19. Random numbers ---------------- */\n\nstatic void sec_randoms(const char *sourceBuf) {\n    h2("19. Random numbers");\n\n    h3("Probe");\n    //#+begin_marker q7w1e3r9t5y\n    /*\n    srand seeds the PRNG deterministically; rand() generates pseudo-random ints in [0, RAND_MAX].\n    Mapping to smaller ranges via modulo introduces bias unless divisible; rejection sampling avoids bias.\n    */\n    //#+end_marker q7w1e3r9t5y\n    print_marked_block_as_c(sourceBuf, "q7w1e3r9t5y");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "q7w1e3r9t5y");\n\n    h3("RAND_MAX and determinism");\n    fence_begin("text");\n    printf("RAND_MAX=%d\\n", RAND_MAX);\n    srand(1234);\n    printf("stream:");\n    for (int i=0;i<5;i++) printf(" %d", rand());\n    printf("\\n");\n    fence_end();\n\n    h3("Modulo bias vs rejection sampling");\n    fence_begin("text");\n    {\n        int n=6;\n        int r = rand() % n;\n        printf("rand() %% %d => %d (biased)\\n", n, r);\n        int bound = RAND_MAX - (RAND_MAX % n);\n        int x;\n        do { x = rand(); } while (x >= bound);\n        printf("rejection sampling into [0,%d): %d (unbiased)\\n", n, x % n);\n    }\n    fence_end();\n}\n\n/* ---------------- 20. Command-line arguments echo ---------------- */\n\nstatic void sec_argv_echo(int argc, char **argv, const char *sourceBuf) {\n    h2("20. Command-line arguments");\n\n    h3("Probe");\n    //#+begin_marker o9i3u7y1t5r\n    /*\n    Print argc and each argv quoted. Then parse with strtol/strtod, showing\n    where parsing stops via endptr, without terminating on errors.\n    */\n    //#+end_marker o9i3u7y1t5r\n    print_marked_block_as_c(sourceBuf, "o9i3u7y1t5r");\n\n    h3("Probe source excerpt");\n    print_marked_block_as_c(sourceBuf, "o9i3u7y1t5r");\n\n    h3("argv echo");\n    fence_begin("text");\n    printf("argc=%d\\n", argc);\n    for (int i=0;i<argc;i++) printf("argv[%d] = \\"%s\\"\\n", i, argv[i]);\n    fence_end();\n\n    h3("strtol and strtod parsing");\n    fence_begin("text");\n    {\n        const char *s1 = "123x", *s2 = "3.14y";\n        char *end = NULL;\n        long v1 = strtol(s1, &end, 10);\n        printf("strtol(\\"%s\\") => %ld, stopped at \\"%s\\"\\n", s1, v1, end);\n        double v2 = strtod(s2, &end);\n        printf("strtod(\\"%s\\") => %f, stopped at \\"%s\\"\\n", s2, v2, end);\n    }\n    fence_end();\n}\n\n/* ---------------- 21. Portability and behavior categories index ---------------- */\n\nstatic void sec_portability_index(void) {\n    h2("21. Portability and behavior categories index");\n    fence_begin("text");\n    printf("Endianness: %s\\n", cat_impldef());\n    printf("Signed right shift of negative: %s\\n", cat_impldef());\n    printf("Struct layout and padding: %s\\n", cat_impldef());\n    printf("Union byte order view: %s\\n", cat_impldef());\n    printf("Sizes, integer and floating limits: %s\\n", cat_defined());\n    printf("VLA size and behavior: %s (if VLA supported by implementation)\\n", cat_defined());\n    printf("Integer literal width selection on 0xFFFFFFFF: %s\\n", cat_impldef());\n    fence_end();\n}\n\n/* ---------------- 22. Report formatting and reproducibility ---------------- */\n\nstatic void sec_footer_appendix(const char *path) {\n    h2("22. Source of this program");\n    fence_begin("c");\n    FILE *f = fopen(path, "rb");\n    if (!f) {\n        printf("/* failed to open %s */\\n", path);\n        fence_end();\n        return;\n    }\n    char buf[4096];\n    size_t n;\n    while ((n = fread(buf, 1, sizeof buf, f)) > 0) {\n        for (size_t i = 0; i < n; ++i) { if (buf[i] != \'\\r\') putchar(buf[i]); }\n    }\n    fclose(f);\n    fence_end();\n}\n\n/* ---------------- main ---------------- */\n\nint main(int argc, char **argv) {\n    char *sourceBuf = read_entire_file(__FILE__);\n\n    printf("# C99 exploratory cheatsheet\\n\\n");\n    printf("This report is produced by running a single C99 program that executes small probes and prints Markdown.\\n\\n");\n    printf("---\\n\\n");\n\n    sec_header_build_env(sourceBuf);\n    sec_fundamental(sourceBuf);\n    sec_literals(sourceBuf);\n    sec_type_system(sourceBuf);\n    sec_sizeof_alignment(sourceBuf);\n    sec_structs_flex(sourceBuf);\n    sec_unions_aliasing(sourceBuf);\n    sec_expr_conv(sourceBuf);\n    sec_operators_eval(sourceBuf);\n    sec_control_flow(sourceBuf);\n    sec_storage_init(sourceBuf);\n    sec_arrays_pointers(sourceBuf);\n    sec_functions_calls(sourceBuf);\n    sec_qsort_bsearch(sourceBuf);\n    sec_time_basics(sourceBuf);\n    sec_memory(sourceBuf);\n    sec_strings_bytes(sourceBuf);\n    sec_ctype_case(sourceBuf);\n    sec_math_special(sourceBuf);\n    sec_randoms(sourceBuf);\n    sec_argv_echo(argc, argv, sourceBuf);\n    sec_portability_index();\n    sec_footer_appendix(__FILE__);\n\n    printf("---\\n\\n");\n    printf("_Generated by a single-file C99 program. Output is platform and compiler specific._\\n");\n\n    free(sourceBuf);\n    return 0;\n}\n')),(0,a.kt)("hr",null),(0,a.kt)("p",null,(0,a.kt)("em",{parentName:"p"},"Generated by a single-file C99 program. Output is platform and compiler specific.")))}p.isMDXComponent=!0}}]);