"use strict";(self.webpackChunkzharii=self.webpackChunkzharii||[]).push([[4179],{96080:function(n,e,t){t.d(e,{Zo:function(){return c},kt:function(){return m}});var a=t(667);function r(n,e,t){return e in n?Object.defineProperty(n,e,{value:t,enumerable:!0,configurable:!0,writable:!0}):n[e]=t,n}function i(n,e){var t=Object.keys(n);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(n);e&&(a=a.filter((function(e){return Object.getOwnPropertyDescriptor(n,e).enumerable}))),t.push.apply(t,a)}return t}function s(n){for(var e=1;e<arguments.length;e++){var t=null!=arguments[e]?arguments[e]:{};e%2?i(Object(t),!0).forEach((function(e){r(n,e,t[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(n,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(e){Object.defineProperty(n,e,Object.getOwnPropertyDescriptor(t,e))}))}return n}function o(n,e){if(null==n)return{};var t,a,r=function(n,e){if(null==n)return{};var t,a,r={},i=Object.keys(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||(r[t]=n[t]);return r}(n,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(n);for(a=0;a<i.length;a++)t=i[a],e.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(n,t)&&(r[t]=n[t])}return r}var d=a.createContext({}),l=function(n){var e=a.useContext(d),t=e;return n&&(t="function"==typeof n?n(e):s(s({},e),n)),t},c=function(n){var e=l(n.components);return a.createElement(d.Provider,{value:e},n.children)},p={inlineCode:"code",wrapper:function(n){var e=n.children;return a.createElement(a.Fragment,{},e)}},u=a.forwardRef((function(n,e){var t=n.components,r=n.mdxType,i=n.originalType,d=n.parentName,c=o(n,["components","mdxType","originalType","parentName"]),u=l(t),m=r,f=u["".concat(d,".").concat(m)]||u[m]||p[m]||i;return t?a.createElement(f,s(s({ref:e},c),{},{components:t})):a.createElement(f,s({ref:e},c))}));function m(n,e){var t=arguments,r=e&&e.mdxType;if("string"==typeof n||r){var i=t.length,s=new Array(i);s[0]=u;var o={};for(var d in e)hasOwnProperty.call(e,d)&&(o[d]=e[d]);o.originalType=n,o.mdxType="string"==typeof n?n:r,s[1]=o;for(var l=2;l<i;l++)s[l]=t[l];return a.createElement.apply(null,s)}return a.createElement.apply(null,t)}u.displayName="MDXCreateElement"},46948:function(n,e,t){t.r(e),t.d(e,{frontMatter:function(){return o},contentTitle:function(){return d},metadata:function(){return l},toc:function(){return c},default:function(){return u}});var a=t(54570),r=t(89462),i=(t(667),t(96080)),s=["components"],o={},d="dev-c99-github-banned-h",l={unversionedId:"dev-c99-github-banned-h",id:"dev-c99-github-banned-h",title:"dev-c99-github-banned-h",description:"Date: 2025-10-03",source:"@site/docs/dev-c99-github-banned-h.md",sourceDirName:".",slug:"/dev-c99-github-banned-h",permalink:"/docs/dev-c99-github-banned-h",editUrl:"https://github.com/dzharii/dzharii.github.io/docs/dev-c99-github-banned-h.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"dev-bicep",permalink:"/docs/dev-bicep"},next:{title:"dev-c99-libraries",permalink:"/docs/dev-c99-libraries"}},c=[{value:"String handling functions",id:"string-handling-functions",children:[{value:"Examples",id:"examples",children:[{value:"<code>strcpy</code>",id:"strcpy",children:[],level:4},{value:"<code>strncpy</code>",id:"strncpy",children:[],level:4},{value:"<code>strcat</code>",id:"strcat",children:[],level:4},{value:"<code>strncat</code>",id:"strncat",children:[],level:4},{value:"<code>strtok</code>",id:"strtok",children:[],level:4}],level:3}],level:2},{value:"Formatted output functions",id:"formatted-output-functions",children:[{value:"Examples",id:"examples-1",children:[{value:"<code>sprintf</code>",id:"sprintf",children:[],level:4},{value:"<code>vsprintf</code>",id:"vsprintf",children:[],level:4}],level:3}],level:2},{value:"Input parsing functions",id:"input-parsing-functions",children:[{value:"Examples",id:"examples-2",children:[{value:"<code>gets</code>",id:"gets",children:[],level:4},{value:"<code>scanf</code> with <code>%s</code>",id:"scanf-with-s",children:[],level:4},{value:"<code>sscanf</code> with scanset <code>%[...]</code>",id:"sscanf-with-scanset-",children:[],level:4},{value:"<code>fscanf</code> and partial reads",id:"fscanf-and-partial-reads",children:[],level:4}],level:3}],level:2},{value:"Numeric conversion functions",id:"numeric-conversion-functions",children:[{value:"Examples",id:"examples-3",children:[{value:"<code>atoi</code>",id:"atoi",children:[],level:4},{value:"<code>atol</code> and <code>atoll</code>",id:"atol-and-atoll",children:[],level:4},{value:"<code>atof</code>",id:"atof",children:[],level:4}],level:3}],level:2}],p={toc:c};function u(n){var e=n.components,o=(0,r.Z)(n,s);return(0,i.kt)("wrapper",(0,a.Z)({},p,o,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"dev-c99-github-banned-h"},"dev-c99-github-banned-h"),(0,i.kt)("p",null,"Date: 2025-10-03"),(0,i.kt)("p",null,"2025-10-03 ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/git/git/blob/master/banned.h"},"git/banned.h at master \xb7 git/git")," { github.com }"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#ifndef BANNED_H\n#define BANNED_H\n\n/*\n * This header lists functions that have been banned from our code base,\n * because they're too easy to misuse (and even if used correctly,\n * complicate audits). Including this header turns them into compile-time\n * errors.\n */\n\n#define BANNED(func) sorry_##func##_is_a_banned_function\n\n#undef strcpy\n#define strcpy(x,y) BANNED(strcpy)\n#undef strcat\n#define strcat(x,y) BANNED(strcat)\n#undef strncpy\n#define strncpy(x,y,n) BANNED(strncpy)\n#undef strncat\n#define strncat(x,y,n) BANNED(strncat)\n#undef strtok\n#define strtok(x,y) BANNED(strtok)\n#undef strtok_r\n#define strtok_r(x,y,z) BANNED(strtok_r)\n\n#undef sprintf\n#undef vsprintf\n#define sprintf(...) BANNED(sprintf)\n#define vsprintf(...) BANNED(vsprintf)\n\n#undef gmtime\n#define gmtime(t) BANNED(gmtime)\n#undef localtime\n#define localtime(t) BANNED(localtime)\n#undef ctime\n#define ctime(t) BANNED(ctime)\n#undef ctime_r\n#define ctime_r(t, buf) BANNED(ctime_r)\n#undef asctime\n#define asctime(t) BANNED(asctime)\n#undef asctime_r\n#define asctime_r(t, buf) BANNED(asctime_r)\n\n#endif /* BANNED_H */\n")),(0,i.kt)("p",null,"See also:"),(0,i.kt)("p",null,"2025-10-03 ",(0,i.kt)("a",{parentName:"p",href:"https://github.com/x509cert/banned"},"x509cert/banned: Banned.h - deprecated C runtime functions")," { github.com }"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'/***\n* banned.h - list of Microsoft Security Development Lifecycle (SDL) banned APIs\n* Copyright (c) Microsoft Corporation. All rights reserved.\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy of this software\n* and associated documentation files (the "Software"), to deal in the Software without \n* restriction, including without limitation the rights to use, copy, modify, merge, publish, \n* distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the\n* Software is furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all copies or \n* substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, \n* INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR \n* PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE\n* FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,\n* ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE \n* SOFTWARE.\n*\n* Purpose:\n*       This include file contains a list of banned APIs which should not be used in new code and \n*       removed from legacy code over time.\n*\n* History\n* 01-Jan-2006 - mikehow  - Initial Version\n* 22-Apr-2008 - mikehow  - Updated to SDL 4.1, commented out recommendations and added memcpy\n* 26-Jan-2009 - mikehow  - Updated to SDL 5.0, made the list sane, added SDL compliance levels\n* 10-Feb-2009 - mikehow  - Updated based on feedback from MS Office\n* 12-May-2009 - jpardue  - Added wmemcpy\n* 08-Jul-2009 - mikehow  - Fixed header #ifndef/#endif logic, made the SDL recommended compliance level name more obvious\n* 05-Nov-2009 - mikehow  - Added vsnprintf (ANSI version of _vsnprintf)\n* 01-Jan-2010 - mikehow  - Added better strsafe integration, now the following works:\n*                           #include "strsafe.h"\n*                           #include "banned.h"\n* 04-Jun-2010 - mikehow  - Small "#if" bug fix\n* 16-Jun-2011 - mikehow  - Added the two _CRT_SECURE_xxxxx macros\n* 07-Jul-2011 - mikehow  - Bugfix when using recommended banned functions and StrSafe. Locally surpressed C4005 warnings\n* 15-Jun-2012 - bryans   - Moved lstrlen to required banned; removed strlen, wcslen, _mbslen, _mbstrlen, StrLen from recommended banned\n* 01-Feb-2013 - martinwo - Added license to header\n* 09-Jan-2014 - mikehow  - Combined the current external and internal versions\n* 10-Feb-2015 - mikehow  - Added gcc/clang support (thanks to Ramsey Dow) \n*                          Note that many of the APIs are Windows specific, however.\n* 18-May-2018 - mikehow  - Updated URL for info about the auto-migrate feature in VC++\n* \n***/\n\n#ifndef _INC_BANNED\n#   define _INC_BANNED\n\n#   if defined(_MSC_VER)\n#       pragma once\n\n// Flip the \'auto-migrate\' functionality in VC++\n// Some functions, such as strcpy() are changed to safer functions by the compiler\n// More info: https://docs.microsoft.com/en-us/cpp/c-runtime-library/secure-template-overloads\n#ifndef _SDL_DONT_AUTO_FIX\n\n#   pragma warning(push)\n#   pragma warning(disable: 4005) // Turns off macro redefinition warnings\n\n    // strcpy etc\n#   define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES          (1)\n\n    // memcpy etc\n#   define _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY   (1)\n\n#   pragma warning(pop)\n\n#endif\n\n        // SDL 6.0 Requirements\n#       if defined(_STRSAFE_H_INCLUDED_) && !defined(STRSAFE_NO_DEPRECATE)\n\n            // Only deprecate what\'s not already deprecated by StrSafe\n#           pragma deprecated (_mbscpy, _mbccpy)\n#           pragma deprecated (strcatA, strcatW, _mbscat, StrCatBuff, StrCatBuffA, StrCatBuffW, StrCatChainW, _tccat, _mbccat)\n#           pragma deprecated (strncpy, wcsncpy, _tcsncpy, _mbsncpy, _mbsnbcpy, StrCpyN, StrCpyNA, StrCpyNW, StrNCpy, strcpynA, StrNCpyA, StrNCpyW, lstrcpyn, lstrcpynA, lstrcpynW)\n#           pragma deprecated (strncat, wcsncat, _tcsncat, _mbsncat, _mbsnbcat, lstrncat, lstrcatnA, lstrcatnW, lstrcatn)\n#           pragma deprecated (IsBadWritePtr, IsBadHugeWritePtr, IsBadReadPtr, IsBadHugeReadPtr, IsBadCodePtr, IsBadStringPtr)\n#           pragma deprecated (memcpy, RtlCopyMemory, CopyMemory, wmemcpy)\n#           pragma deprecated (lstrlen)\n\n#       else\n            // StrSafe not loaded, so deprecate everything!\n#           pragma deprecated (strcpy, strcpyA, strcpyW, wcscpy, _tcscpy, _mbscpy, StrCpy, StrCpyA, StrCpyW, lstrcpy, lstrcpyA, lstrcpyW, _tccpy, _mbccpy, _ftcscpy)\n#           pragma deprecated (strcat, strcatA, strcatW, wcscat, _tcscat, _mbscat, StrCat, StrCatA, StrCatW, lstrcat, lstrcatA, lstrcatW, StrCatBuff, StrCatBuffA, StrCatBuffW, StrCatChainW, _tccat, _mbccat, _ftcscat)\n#           pragma deprecated (sprintfW, sprintfA, wsprintf, wsprintfW, wsprintfA, sprintf, swprintf, _stprintf)\n#           pragma deprecated (wvsprintf, wvsprintfA, wvsprintfW, vsprintf, _vstprintf, vswprintf)\n#           pragma deprecated (strncpy, wcsncpy, _tcsncpy, _mbsncpy, _mbsnbcpy, StrCpyN, StrCpyNA, StrCpyNW, StrNCpy, strcpynA, StrNCpyA, StrNCpyW, lstrcpyn, lstrcpynA, lstrcpynW)\n#           pragma deprecated (strncat, wcsncat, _tcsncat, _mbsncat, _mbsnbcat, StrCatN, StrCatNA, StrCatNW, StrNCat, StrNCatA, StrNCatW, lstrncat, lstrcatnA, lstrcatnW, lstrcatn)\n#           pragma deprecated (gets, _getts, _gettws)\n#           pragma deprecated (IsBadWritePtr, IsBadHugeWritePtr, IsBadReadPtr, IsBadHugeReadPtr, IsBadCodePtr, IsBadStringPtr)\n#           pragma deprecated (memcpy, RtlCopyMemory, CopyMemory, wmemcpy)\n#           pragma deprecated (lstrlen)\n#       endif //defined(_STRSAFE_H_INCLUDED_) && !defined(STRSAFE_NO_DEPRECATE)\n\n        // SDL 6.0 Recommendations\n#       if defined(_SDL_BANNED_RECOMMENDED)\n#           if defined(_STRSAFE_H_INCLUDED_) && !defined(STRSAFE_NO_DEPRECATE)\n                // Only deprecate what\'s not already deprecated by StrSafe\n#               pragma deprecated (wnsprintf, wnsprintfA, wnsprintfW)\n#               pragma deprecated (vsnprintf, wvnsprintf, wvnsprintfA, wvnsprintfW)\n#               pragma deprecated (strtok, _tcstok, wcstok, _mbstok)\n#               pragma deprecated (makepath, _tmakepath,  _makepath, _wmakepath)\n#               pragma deprecated (_splitpath, _tsplitpath, _wsplitpath)\n#               pragma deprecated (scanf, wscanf, _tscanf, sscanf, swscanf, _stscanf, snscanf, snwscanf, _sntscanf)\n#               pragma deprecated (_itoa, _itow, _i64toa, _i64tow, _ui64toa, _ui64tot, _ui64tow, _ultoa, _ultot, _ultow)\n#               pragma deprecated (CharToOem, CharToOemA, CharToOemW, OemToChar, OemToCharA, OemToCharW, CharToOemBuffA, CharToOemBuffW)\n#               pragma deprecated (alloca, _alloca)\n#               pragma deprecated (ChangeWindowMessageFilter)\n#           else\n                // StrSafe not loaded, so deprecate everything!\n#               pragma deprecated (wnsprintf, wnsprintfA, wnsprintfW, _snwprintf, _snprintf, _sntprintf)\n#               pragma deprecated (_vsnprintf, vsnprintf, _vsnwprintf, _vsntprintf, wvnsprintf, wvnsprintfA, wvnsprintfW)\n#               pragma deprecated (strtok, _tcstok, wcstok, _mbstok)\n#               pragma deprecated (makepath, _tmakepath,  _makepath, _wmakepath)\n#               pragma deprecated (_splitpath, _tsplitpath, _wsplitpath)\n#               pragma deprecated (scanf, wscanf, _tscanf, sscanf, swscanf, _stscanf, snscanf, snwscanf, _sntscanf)\n#               pragma deprecated (_itoa, _itow, _i64toa, _i64tow, _ui64toa, _ui64tot, _ui64tow, _ultoa, _ultot, _ultow)\n#               pragma deprecated (CharToOem, CharToOemA, CharToOemW, OemToChar, OemToCharA, OemToCharW, CharToOemBuffA, CharToOemBuffW)\n#               pragma deprecated (alloca, _alloca)\n#               pragma deprecated (ChangeWindowMessageFilter)\n#           endif // StrSafe\n#       endif // SDL recommended\n\n# else\n\n# if defined __clang__\n#       pragma clang system_header\n# endif // __clang__\n\n        // SDL 6.0 and later Requirements\n#       pragma GCC poison strcpy strcpyA strcpyW wcscpy _tcscpy _mbscpy StrCpy StrCpyA StrCpyW lstrcpy lstrcpyA lstrcpyW _tccpy _mbccpy _ftcscpy\n#       pragma GCC poison strcat strcatA strcatW wcscat _tcscat _mbscat StrCat StrCatA StrCatW lstrcat lstrcatA lstrcatW StrCatBuff StrCatBuffA StrCatBuffW StrCatChainW _tccat _mbccat _ftcscat\n#       pragma GCC poison sprintfW sprintfA wsprintf wsprintfW wsprintfA sprintf swprintf _stprintf\n#       pragma GCC poison wvsprintf wvsprintfA wvsprintfW vsprintf _vstprintf vswprintf\n#       pragma GCC poison strncpy wcsncpy _tcsncpy _mbsncpy _mbsnbcpy StrCpyN StrCpyNA StrCpyNW StrNCpy strcpynA StrNCpyA StrNCpyW lstrcpyn lstrcpynA lstrcpynW\n#       pragma GCC poison strncat wcsncat _tcsncat _mbsncat _mbsnbcat StrCatN StrCatNA StrCatNW StrNCat StrNCatA StrNCatW lstrncat lstrcatnA lstrcatnW lstrcatn\n#       pragma GCC poison gets _getts _gettws\n#       pragma GCC poison IsBadWritePtr IsBadHugeWritePtr IsBadReadPtr IsBadHugeReadPtr IsBadCodePtr IsBadStringPtr\n#       pragma GCC poison memcpy RtlCopyMemory CopyMemory wmemcpy\n#       pragma GCC poison lstrlen\n\n#if     defined(_SDL_BANNED_RECOMMENDED)\n            // SDL 6.0 and later Recommendations\n#           pragma GCC poison wnsprintf wnsprintfA wnsprintfW _snwprintf _snprintf _sntprintf\n#           pragma GCC poison _vsnprintf vsnprintf _vsnwprintf _vsntprintf wvnsprintf wvnsprintfA wvnsprintfW\n#           pragma GCC poison strtok _tcstok wcstok _mbstok\n#           pragma GCC poison makepath _tmakepath _makepath _wmakepath\n#           pragma GCC poison _splitpath _tsplitpath _wsplitpath\n#           pragma GCC poison scanf wscanf _tscanf sscanf swscanf _stscanf snscanf snwscanf _sntscanf\n#           pragma GCC poison _itoa _itow _i64toa _i64tow _ui64toa _ui64tot _ui64tow _ultoa _ultot _ultow\n#           pragma GCC poison CharToOem CharToOemA CharToOemW OemToChar OemToCharA OemToCharW CharToOemBuffA CharToOemBuffW\n#           pragma GCC poison alloca _alloca\n#           pragma GCC poison ChangeWindowMessageFilter\n\n#       endif\n#   endif // _MSC_VER_\n#endif  // _INC_BANNED \n')),(0,i.kt)("p",null,"2025-10-03 ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.openstack.org/wiki/StarlingX/Security/Banned_C_Functions"},"StarlingX/Security/Banned C Functions - OpenStack")," { wiki.openstack.org }"),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("img",{alt:"image-20251003120826669",src:t(25838).Z,width:"1117",height:"598"}))),(0,i.kt)("p",null,"Prohibiting the use of banned functions is a good way to remove a significant number of potential code vulnerabilities from C and C++ code. This list is the compiled library of known bad functions that should be removed to reduce vulnerabilities. It is derived from experience with real-world security bugs and focuses primarily on functions that can lead to buffer overruns (reference: ",(0,i.kt)("a",{parentName:"p",href:"https://msdn.microsoft.com/en-us/library/bb288454.aspx"},"msdn"),")."),(0,i.kt)("p",null,"Specifically, for Starling X, the main guidelines are that:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Only functions in the standard C runtime library\u2014libc\u2014are mandated"),(0,i.kt)("li",{parentName:"ul"},"Unbounded functions are banned unless specifically noted"),(0,i.kt)("li",{parentName:"ul"},"Stack allocation functions are banned unless specifically approved by the project core")),(0,i.kt)("p",null,"There is no requirement to retrofit existing upstream code to meet these guidelines. A summary of the policy is provided below."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Func"),(0,i.kt)("th",{parentName:"tr",align:null},"Status"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"strcpy, wcscpy"),(0,i.kt)("td",{parentName:"tr",align:null},"unbounded, ",(0,i.kt)("strong",{parentName:"td"},"banned"),"; use strncpy")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"strncpy"),(0,i.kt)("td",{parentName:"tr",align:null},"inspect for unterminated/truncated output")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"strcat, wcscat"),(0,i.kt)("td",{parentName:"tr",align:null},"unbounded, ",(0,i.kt)("strong",{parentName:"td"},"banned"),"; use strncat")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"strncat"),(0,i.kt)("td",{parentName:"tr",align:null},"inspect for truncated output and buffer overflow")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"sprintf, vsprintf"),(0,i.kt)("td",{parentName:"tr",align:null},"unbounded, ",(0,i.kt)("strong",{parentName:"td"},"banned"),"; use snprintf, vsnprintf")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"snprintf"),(0,i.kt)("td",{parentName:"tr",align:null},"inspect for result fitting in buffer: snprintf(buf, size, ...) < size")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"vsnprintf"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"banned")," except with approval from core. requires detailed inspection to avoid va_list pitfalls.vsnprint() is typically used for custom logging functionality. Given the flexibility of this function, it is easy to mismatch data types pushed on the stack for a va-list function and types pulled from the stack by the function. The core needs to ensure that the format matches the variables passed to avoid mismatches.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"strtok"),(0,i.kt)("td",{parentName:"tr",align:null},"unbounded, ",(0,i.kt)("strong",{parentName:"td"},"banned"),"; use strtok_r or strsep")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"strtok_r, strsep"),(0,i.kt)("td",{parentName:"tr",align:null},"Inspect for terminated input buffer")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"scanf, sscanf, vscanf, vsscanf"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"banned")," except with approval of core. Requires detailed inspection to ensure field widths are specified. For unknown inputs, it is recommended to use strto* functions to avoid arithmetic overflows.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"gets"),(0,i.kt)("td",{parentName:"tr",align:null},"unbounded, ",(0,i.kt)("strong",{parentName:"td"},"banned"),", use fgets() instead")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ato*"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"banned"),", use equivalent strto* functions")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"*toa"),(0,i.kt)("td",{parentName:"tr",align:null},"Non-standard, inspect for output buffer length; prefer snprintf")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"strlen, wcslen"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"banned")," except static strings; use strnlen with max length constant")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"memcpy, memmove"),(0,i.kt)("td",{parentName:"tr",align:null},"allowed")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"alloca"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"banned")," except with approval of core. Requires detailed inspection to avoid stack overflow. In general, it is preferable to allocate from the heap using malloc() or calloc().alloca() returns a pointer to a buffer located on the current thread's stack vs. the heap like malloc(). It's often used in cases where performance is especially important, but data length is unknown beforehand, because allocation is a simple matter of moving the stack pointer for the currently executing function. The dangers of using alloca() are stack space exhaustion or a buffer overflow which corrupts local variables.If alloca() is used, the designer needs to understand that:alloca() makes no guarantees about alignment and in most cases provides no overflow canaries that may exist in heap buffersNever use alloca() in a loop where the bounds are not known beforehand. There is no ability to free memory allocated with alloca() unless you return from the function. If a long function continually calls alloca() in a loop, there is a high risk of stack exhaustion.The conversion of alloca() to malloc() or calloc() requires a free() calls to be added as well")))),(0,i.kt)("h2",{id:"string-handling-functions"},"String handling functions"),(0,i.kt)("p",null,"String routines that copy or concatenate omit length checks. Functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"strcpy")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"strcat")," always trust the caller to allocate enough space. See ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.openstack.org/wiki/StarlingX/Security/Banned_C_Functions"},"StarlingX banned C functions")," and why even \u201cbounded\u201d variants can still bite. For example, ",(0,i.kt)("inlineCode",{parentName:"p"},"strncpy")," does not guarantee a trailing ",(0,i.kt)("inlineCode",{parentName:"p"},"\\0")," if the source is at least ",(0,i.kt)("inlineCode",{parentName:"p"},"n")," bytes, and it pads with zeros. See ",(0,i.kt)("a",{parentName:"p",href:"https://help.klocwork.com/2024/en-us/reference/sv.banned.recommended.numeric.htm"},"Klocwork notes on banned and recommended APIs"),". Prefer explicit length checks and safer patterns."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Issue, safer alternative"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"strcpy")),(0,i.kt)("td",{parentName:"tr",align:null},"Copies without a size check, can overflow. Ensure capacity or use a length aware copy.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"strncpy")),(0,i.kt)("td",{parentName:"tr",align:null},"May not append ",(0,i.kt)("inlineCode",{parentName:"td"},"\\0")," when the source length is at least ",(0,i.kt)("inlineCode",{parentName:"td"},"n"),", can truncate silently. Add explicit terminator or use a checked copy.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"strcat")),(0,i.kt)("td",{parentName:"tr",align:null},"Appends without a size check, can overflow. Compute remaining space and use a bounded append.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"strncat")),(0,i.kt)("td",{parentName:"tr",align:null},"The count is the remaining capacity, not the source length, easy to misuse. Compute remaining space first.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"strtok")),(0,i.kt)("td",{parentName:"tr",align:null},"Modifies the input buffer and uses hidden global state, not thread safe. Use a reentrant tokenizer or manual parsing.")))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"examples"},"Examples"),(0,i.kt)("h4",{id:"strcpy"},(0,i.kt)("inlineCode",{parentName:"h4"},"strcpy")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: strcpy overflows when the destination is too small.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char dst[8];\n    const char *src = "too-long"; // 8 chars including \'\\0\' would fit exactly, add 1 more to overflow\n    src = "definitely-longer";    // longer than dst\n\n    // Undefined behavior, writes past dst\n    strcpy(dst, src);\n\n    printf("dst: %s\\n", dst); // may crash or corrupt memory\n    return 0;\n}\n// Avoidance example: check lengths and copy with an explicit bound and terminator.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char dst[8];\n    const char *src = "definitely-longer";\n    size_t cap = sizeof dst;\n\n    size_t need = strlen(src) + 1;          // include \'\\0\'\n    if (need > cap) {\n        // truncate safely\n        size_t to_copy = cap - 1;\n        memcpy(dst, src, to_copy);\n        dst[to_copy] = \'\\0\';\n    } else {\n        memcpy(dst, src, need);\n    }\n\n    printf("dst: %s\\n", dst);\n    return 0;\n}\n')),(0,i.kt)("h4",{id:"strncpy"},(0,i.kt)("inlineCode",{parentName:"h4"},"strncpy")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Failure example: strncpy may omit the trailing '\\0' when source length >= n.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char dst[5];\n    const char *src = \"ABCDE\"; // length 5, no room for '\\0' if n == 5\n\n    strncpy(dst, src, sizeof dst); // no guarantee of '\\0'\n    // dst is not necessarily null terminated here\n\n    // Using dst as a C string now is undefined behavior\n    printf(\"dst: %s\\n\", dst); // may read past dst\n    return 0;\n}\n// Avoidance example: copy up to cap-1 and append '\\0' yourself.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char dst[5];\n    const char *src = \"ABCDE\";\n\n    size_t cap = sizeof dst;\n    size_t to_copy = strlen(src);\n    if (to_copy >= cap) to_copy = cap - 1;\n\n    memcpy(dst, src, to_copy);\n    dst[to_copy] = '\\0';\n\n    printf(\"dst: %s\\n\", dst);\n    return 0;\n}\n")),(0,i.kt)("h4",{id:"strcat"},(0,i.kt)("inlineCode",{parentName:"h4"},"strcat")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: strcat overflows when the buffer cannot hold the result.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char buf[8] = "abc";\n    const char *add = "defghi"; // result would need 3 + 6 + 1 = 10 bytes\n\n    // Undefined behavior, writes past buf\n    strcat(buf, add);\n\n    printf("buf: %s\\n", buf); // may crash or corrupt memory\n    return 0;\n}\n// Avoidance example: compute remaining space and append at most that many chars.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char buf[8] = "abc";\n    const char *add = "defghi";\n\n    size_t used = strlen(buf);\n    size_t cap = sizeof buf;\n    if (used < cap) {\n        size_t rem = cap - used - 1;       // space left for new chars\n        size_t to_copy = strlen(add);\n        if (to_copy > rem) to_copy = rem;  // truncate if needed\n        memcpy(buf + used, add, to_copy);\n        buf[used + to_copy] = \'\\0\';\n    }\n\n    printf("buf: %s\\n", buf);\n    return 0;\n}\n')),(0,i.kt)("h4",{id:"strncat"},(0,i.kt)("inlineCode",{parentName:"h4"},"strncat")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: passing sizeof(buf) instead of remaining space causes overflow.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char buf[8] = "abc";\n    const char *add = "def";\n\n    // Wrong: count should be remaining capacity, not total size\n    strncat(buf, add, sizeof buf); // may write past buf due to internal scan\n\n    printf("buf: %s\\n", buf); // undefined behavior possible\n    return 0;\n}\n// Avoidance example: compute remaining space before calling strncat, or append manually.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char buf[8] = "abc";\n    const char *add = "def";\n\n    size_t used = strlen(buf);\n    size_t cap = sizeof buf;\n    size_t rem = (used < cap) ? (cap - used - 1) : 0;\n\n    strncat(buf, add, rem); // safe when rem is computed as remaining space\n\n    printf("buf: %s\\n", buf);\n    return 0;\n}\n')),(0,i.kt)("h4",{id:"strtok"},(0,i.kt)("inlineCode",{parentName:"h4"},"strtok")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: strtok modifies the buffer and uses hidden global state.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char data[] = "a,b,c";\n    // strtok writes \'\\0\' into data and keeps static state\n    char *tok = strtok(data, ",");\n    while (tok) {\n        printf("[%s]\\n", tok);\n        tok = strtok(NULL, ",");\n    }\n    // Original string is now "a\\0b\\0c", the commas are gone\n    printf("original mutated: %s\\n", data); // prints "a"\n    return 0;\n}\n// Avoidance example: do not mutate the original, parse with strchr on a read-only source.\n#include <stdio.h>\n#include <string.h>\n\nstatic void split_commas(const char *s) {\n    const char *p = s;\n    while (p && *p) {\n        const char *comma = strchr(p, \',\');\n        size_t len = comma ? (size_t)(comma - p) : strlen(p);\n        // Print token without modifying the source\n        printf("[%.*s]\\n", (int)len, p);\n        p = comma ? comma + 1 : NULL;\n    }\n}\n\nint main(void) {\n    const char *data = "a,b,c";\n    split_commas(data);\n    // data remains unchanged and the function is reentrant\n    printf("original intact: %s\\n", data);\n    return 0;\n}\n')),(0,i.kt)("h2",{id:"formatted-output-functions"},"Formatted output functions"),(0,i.kt)("p",null,"Functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"sprintf")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"vsprintf")," write formatted text into a buffer without any length limit. If the result exceeds the buffer, the write overflows. Prefer ",(0,i.kt)("inlineCode",{parentName:"p"},"snprintf")," or ",(0,i.kt)("inlineCode",{parentName:"p"},"vsnprintf"),", and check the return value. "),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Issue, safer alternative"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"sprintf")),(0,i.kt)("td",{parentName:"tr",align:null},"Writes without a size limit, can overflow. Use ",(0,i.kt)("inlineCode",{parentName:"td"},"snprintf"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"vsprintf")),(0,i.kt)("td",{parentName:"tr",align:null},"Same issue with varargs. Use ",(0,i.kt)("inlineCode",{parentName:"td"},"vsnprintf"),".")))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"examples-1"},"Examples"),(0,i.kt)("h4",{id:"sprintf"},(0,i.kt)("inlineCode",{parentName:"h4"},"sprintf")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: sprintf overflows when the result does not fit.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char buf[8];\n    const char *name = "charlie"; // 7 chars\n\n    // Needs at least 7 + 6 + 1 bytes for "user: " + name + \'\\0\'\n    // Writes past buf, causes undefined behavior\n    sprintf(buf, "user: %s", name);\n\n    printf("%s\\n", buf); // may crash or corrupt memory\n    return 0;\n}\n// Avoidance example: use snprintf and check for truncation.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char buf[8];\n    const char *name = "charlie";\n\n    int n = snprintf(buf, sizeof buf, "user: %s", name);\n    if (n < 0) {\n        // formatting error\n        return 1;\n    }\n    if ((size_t)n >= sizeof buf) {\n        // truncated, handle or resize\n        puts("truncated");\n    } else {\n        puts(buf);\n    }\n    return 0;\n}\n// Avoidance example: compute required size, then allocate.\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void) {\n    const char *name = "charlie";\n    int need = snprintf(NULL, 0, "user: %s", name);\n    if (need < 0) return 1;\n\n    char *buf = malloc((size_t)need + 1);\n    if (!buf) return 1;\n\n    snprintf(buf, (size_t)need + 1, "user: %s", name);\n    puts(buf);\n    free(buf);\n    return 0;\n}\n')),(0,i.kt)("h4",{id:"vsprintf"},(0,i.kt)("inlineCode",{parentName:"h4"},"vsprintf")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: helper that forwards to vsprintf without bounds.\n#include <stdio.h>\n#include <stdarg.h>\n\nstatic int format_into(char *dst, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    // No size, writes past dst if output is too large\n    int n = vsprintf(dst, fmt, ap);\n    va_end(ap);\n    return n;\n}\n\nint main(void) {\n    char buf[16];\n    format_into(buf, "id=%d name=%s", 42, "a-very-long-user-name");\n    puts(buf); // undefined behavior possible\n    return 0;\n}\n// Avoidance example: safe wrapper that uses vsnprintf and checks the result.\n#include <stdio.h>\n#include <stdarg.h>\n#include <string.h>\n\nstatic int vformat_into(char *dst, size_t cap, const char *fmt, va_list ap) {\n    int n = vsnprintf(dst, cap, fmt, ap);\n    if (n < 0) return -1;                 // formatting error\n    if ((size_t)n >= cap) return n;       // truncated, caller may reallocate\n    return n;                              // success\n}\n\nstatic int format_into(char *dst, size_t cap, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    int n = vformat_into(dst, cap, fmt, ap);\n    va_end(ap);\n    return n;\n}\n\nint main(void) {\n    char buf[16];\n    int n = format_into(buf, sizeof buf, "id=%d name=%s", 42, "bob");\n    if (n < 0) return 1;\n    if ((size_t)n >= sizeof buf) {\n        puts("truncated");\n    } else {\n        puts(buf);\n    }\n    return 0;\n}\n')),(0,i.kt)("h2",{id:"input-parsing-functions"},"Input parsing functions"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"gets")," reads a line with no limit. C11 removed it. ",(0,i.kt)("inlineCode",{parentName:"p"},"scanf")," and friends read unbounded text for ",(0,i.kt)("inlineCode",{parentName:"p"},"%s")," or scansets like ",(0,i.kt)("inlineCode",{parentName:"p"},"%[...]")," unless you include a field width. Prefer ",(0,i.kt)("inlineCode",{parentName:"p"},"fgets"),", or always specify a maximum width."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Issue, safer alternative"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"gets")),(0,i.kt)("td",{parentName:"tr",align:null},"Reads until newline with no limit, overflows. Use ",(0,i.kt)("inlineCode",{parentName:"td"},"fgets(buf, n, stdin)"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"scanf")," / ",(0,i.kt)("inlineCode",{parentName:"td"},"sscanf")," with ",(0,i.kt)("inlineCode",{parentName:"td"},"%s")),(0,i.kt)("td",{parentName:"tr",align:null},"No width means unbounded read. Use ",(0,i.kt)("inlineCode",{parentName:"td"},'"%Ns"')," with the correct ",(0,i.kt)("inlineCode",{parentName:"td"},"N"),", or ",(0,i.kt)("inlineCode",{parentName:"td"},"fgets"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"scanf")," / ",(0,i.kt)("inlineCode",{parentName:"td"},"sscanf")," with ",(0,i.kt)("inlineCode",{parentName:"td"},"%[...]")),(0,i.kt)("td",{parentName:"tr",align:null},"No width means unbounded read. Use ",(0,i.kt)("inlineCode",{parentName:"td"},'"%N[...]"')," with the correct ",(0,i.kt)("inlineCode",{parentName:"td"},"N"),", or ",(0,i.kt)("inlineCode",{parentName:"td"},"fgets"),".")))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"examples-2"},"Examples"),(0,i.kt)("h4",{id:"gets"},(0,i.kt)("inlineCode",{parentName:"h4"},"gets")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"// Failure example: gets overflows when the input line exceeds the buffer.\n#include <stdio.h>\n\nint main(void) {\n    char buf[8];\n\n    // Dangerous: reads an arbitrarily long line into buf\n    // Any input > 7 chars plus '\\0' will overflow\n    gets(buf); // removed in C11, undefined behavior in practice\n\n    printf(\"read: %s\\n\", buf);\n    return 0;\n}\n// Avoidance example: use fgets with an explicit bound and strip the newline.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char buf[8];\n\n    if (fgets(buf, sizeof buf, stdin)) {\n        // Remove trailing '\\n' if present\n        buf[strcspn(buf, \"\\n\")] = '\\0';\n        printf(\"read: %s\\n\", buf);\n    }\n    return 0;\n}\n")),(0,i.kt)("h4",{id:"scanf-with-s"},(0,i.kt)("inlineCode",{parentName:"h4"},"scanf")," with ",(0,i.kt)("inlineCode",{parentName:"h4"},"%s")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: scanf("%s") overflows when the word is longer than the array.\n#include <stdio.h>\n\nint main(void) {\n    char name[8];\n\n    // If the user types "alexandria", this writes past name\n    printf("name: ");\n    if (scanf("%s", name) == 1) { // no width, unbounded\n        printf("got: %s\\n", name);\n    }\n    return 0;\n}\n// Avoidance example: add a width that leaves space for the \'\\0\'.\n#include <stdio.h>\n\nint main(void) {\n    char name[8];\n\n    // Width is capacity - 1. Here, 7.\n    printf("name: ");\n    if (scanf("%7s", name) == 1) {\n        printf("got: %s\\n", name);\n    }\n    return 0;\n}\n// Avoidance example: prefer fgets, then parse if needed.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char line[32];\n    char name[8];\n\n    printf("name: ");\n    if (fgets(line, sizeof line, stdin)) {\n        line[strcspn(line, "\\n")] = \'\\0\';\n        // Parse with a bounded conversion, or copy safely\n        // Here we just take up to 7 chars\n        size_t n = strlen(line);\n        if (n > sizeof name - 1) n = sizeof name - 1;\n        memcpy(name, line, n);\n        name[n] = \'\\0\';\n        printf("got: %s\\n", name);\n    }\n    return 0;\n}\n')),(0,i.kt)("h4",{id:"sscanf-with-scanset-"},(0,i.kt)("inlineCode",{parentName:"h4"},"sscanf")," with scanset ",(0,i.kt)("inlineCode",{parentName:"h4"},"%[...]")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: scanset without width reads until delimiter, unbounded.\n#include <stdio.h>\n\nint main(void) {\n    const char *input = "toolongvalue,rest";\n    char field[8];\n\n    // Reads everything up to \',\' into field with no bound, overflows field\n    if (sscanf(input, "%[^,]", field) == 1) {\n        printf("field: %s\\n", field);\n    }\n    return 0;\n}\n// Avoidance example: add a width to scanset to cap the write.\n#include <stdio.h>\n\nint main(void) {\n    const char *input = "toolongvalue,rest";\n    char field[8];\n\n    // Width is capacity - 1. Here, 7.\n    if (sscanf(input, "%7[^,]", field) == 1) {\n        printf("field: %s\\n", field);\n    } else {\n        puts("no match or truncated");\n    }\n    return 0;\n}\n')),(0,i.kt)("h4",{id:"fscanf-and-partial-reads"},(0,i.kt)("inlineCode",{parentName:"h4"},"fscanf")," and partial reads"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: fscanf("%s") can leave unread input and overflow the target.\n#include <stdio.h>\n\nint main(void) {\n    char user[8];\n    char rest[8];\n\n    // Input: "verylongusername data"\n    // First read may overflow user, and the space-delimited remainder stays buffered\n    if (fscanf(stdin, "%s", user) == 1 &&\n        fscanf(stdin, "%7s", rest) == 1) {\n        printf("user=%s rest=%s\\n", user, rest);\n    }\n    return 0;\n}\n// Avoidance example: read a whole line with fgets, then parse with widths.\n#include <stdio.h>\n#include <string.h>\n\nint main(void) {\n    char line[64];\n    char user[8], rest[8];\n\n    if (fgets(line, sizeof line, stdin)) {\n        line[strcspn(line, "\\n")] = \'\\0\';\n        // Both fields bounded, no buffer overrun\n        if (sscanf(line, "%7s %7s", user, rest) == 2) {\n            printf("user=%s rest=%s\\n", user, rest);\n        }\n    }\n    return 0;\n}\n')),(0,i.kt)("h2",{id:"numeric-conversion-functions"},"Numeric conversion functions"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"atoi"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"atof"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"atol"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"atoll")," do not report errors or overflow. Invalid input and out-of-range values look the same as valid zeros or wrapped results. Prefer ",(0,i.kt)("inlineCode",{parentName:"p"},"strtol"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"strtoll"),", and ",(0,i.kt)("inlineCode",{parentName:"p"},"strtod"),", which let you detect errors. See ",(0,i.kt)("a",{parentName:"p",href:"https://wiki.sei.cmu.edu/confluence/display/c/MSC24-C.+Do+not+use+deprecated+or+obsolescent+functions"},"SEI CERT MSC24-C"),"."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Function"),(0,i.kt)("th",{parentName:"tr",align:null},"Issue, safer alternative"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"atoi")),(0,i.kt)("td",{parentName:"tr",align:null},"No error reporting, overflow is undefined. Use ",(0,i.kt)("inlineCode",{parentName:"td"},"strtol"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"atol")," / ",(0,i.kt)("inlineCode",{parentName:"td"},"atoll")),(0,i.kt)("td",{parentName:"tr",align:null},"Same problem for long types. Use ",(0,i.kt)("inlineCode",{parentName:"td"},"strtol")," or ",(0,i.kt)("inlineCode",{parentName:"td"},"strtoll"),".")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("inlineCode",{parentName:"td"},"atof")),(0,i.kt)("td",{parentName:"tr",align:null},"No error reporting, cannot tell NaN or overflow. Use ",(0,i.kt)("inlineCode",{parentName:"td"},"strtod"),".")))),(0,i.kt)("hr",null),(0,i.kt)("h3",{id:"examples-3"},"Examples"),(0,i.kt)("h4",{id:"atoi"},(0,i.kt)("inlineCode",{parentName:"h4"},"atoi")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: atoi cannot report errors or overflow.\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void) {\n    const char *s1 = "not-a-number";\n    const char *s2 = "9999999999999999999999"; // may overflow int\n\n    int a = atoi(s1); // returns 0, same as a valid "0", error is silent\n    int b = atoi(s2); // overflow, result is undefined\n\n    printf("a=%d b=%d\\n", a, b);\n    return 0;\n}\n// Avoidance example: use strtol with endptr and errno checks.\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <limits.h>\n\nstatic int parse_int(const char *s, int *out) {\n    errno = 0;\n    char *end = NULL;\n    long v = strtol(s, &end, 10);\n    if (end == s) return -1;                 // no digits\n    if (*end != \'\\0\') return -1;             // trailing junk\n    if ((errno == ERANGE) || v < INT_MIN || v > INT_MAX) return -1; // overflow\n    *out = (int)v;\n    return 0;\n}\n\nint main(void) {\n    int x;\n    if (parse_int("123", &x) == 0) printf("ok %d\\n", x);\n    if (parse_int("9999999999999999999999", &x) != 0) puts("overflow detected");\n    if (parse_int("not-a-number", &x) != 0) puts("invalid detected");\n    return 0;\n}\n')),(0,i.kt)("h4",{id:"atol-and-atoll"},(0,i.kt)("inlineCode",{parentName:"h4"},"atol")," and ",(0,i.kt)("inlineCode",{parentName:"h4"},"atoll")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: atol and atoll also hide errors and overflow.\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void) {\n    const char *s = "18446744073709551616"; // larger than 2^64\n    long l = atol(s);    // overflow, undefined result\n    long long ll = atoll(s); // overflow, undefined result\n    printf("l=%ld ll=%lld\\n", l, ll);\n    return 0;\n}\n// Avoidance example: use strtoll with range checks.\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <limits.h>\n\nstatic int parse_long_long(const char *s, long long *out) {\n    errno = 0;\n    char *end = NULL;\n    long long v = strtoll(s, &end, 10);\n    if (end == s) return -1;          // no digits\n    if (*end != \'\\0\') return -1;      // trailing junk\n    if (errno == ERANGE) return -1;   // overflow or underflow\n    *out = v;\n    return 0;\n}\n\nint main(void) {\n    long long y;\n    if (parse_long_long("9223372036854775807", &y) == 0) printf("ok %lld\\n", y);\n    if (parse_long_long("9223372036854775808", &y) != 0) puts("overflow detected");\n    return 0;\n}\n')),(0,i.kt)("h4",{id:"atof"},(0,i.kt)("inlineCode",{parentName:"h4"},"atof")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'// Failure example: atof cannot distinguish invalid input from 0.0 and hides overflow.\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(void) {\n    const char *a = "abc";    // invalid\n    const char *b = "0";      // valid zero\n    const char *c = "1e5000"; // overflow to infinity on many libs\n\n    double x = atof(a); // returns 0.0, same as valid "0"\n    double y = atof(b); // returns 0.0\n    double z = atof(c); // may be HUGE_VAL, but no errno or endptr available here\n\n    printf("x=%f y=%f z=%f\\n", x, y, z);\n    return 0;\n}\n// Avoidance example: use strtod, check endptr and errno for range errors.\n#include <stdio.h>\n#include <stdlib.h>\n#include <errno.h>\n#include <math.h>\n\nstatic int parse_double(const char *s, double *out) {\n    errno = 0;\n    char *end = NULL;\n    double v = strtod(s, &end);\n    if (end == s) return -1;         // no digits\n    if (*end != \'\\0\') return -1;     // trailing junk\n    if (errno == ERANGE) return -1;  // underflow or overflow\n    *out = v;\n    return 0;\n}\n\nint main(void) {\n    double d;\n    if (parse_double("3.14159", &d) == 0) printf("ok %f\\n", d);\n    if (parse_double("1e5000", &d) != 0) puts("overflow detected");\n    if (parse_double("abc", &d) != 0) puts("invalid detected");\n    return 0;\n}\n')))}u.isMDXComponent=!0},25838:function(n,e,t){e.Z=t.p+"assets/images/image-20251003120826669-f58c8fd617f9c77fc53d311e31596562.png"}}]);