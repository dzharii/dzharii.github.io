"use strict";(self.webpackChunkzharii=self.webpackChunkzharii||[]).push([[3599],{96080:function(e,n,t){t.d(n,{Zo:function(){return u},kt:function(){return m}});var a=t(667);function r(e,n,t){return n in e?Object.defineProperty(e,n,{value:t,enumerable:!0,configurable:!0,writable:!0}):e[n]=t,e}function i(e,n){var t=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);n&&(a=a.filter((function(n){return Object.getOwnPropertyDescriptor(e,n).enumerable}))),t.push.apply(t,a)}return t}function l(e){for(var n=1;n<arguments.length;n++){var t=null!=arguments[n]?arguments[n]:{};n%2?i(Object(t),!0).forEach((function(n){r(e,n,t[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(t)):i(Object(t)).forEach((function(n){Object.defineProperty(e,n,Object.getOwnPropertyDescriptor(t,n))}))}return e}function s(e,n){if(null==e)return{};var t,a,r=function(e,n){if(null==e)return{};var t,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||(r[t]=e[t]);return r}(e,n);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)t=i[a],n.indexOf(t)>=0||Object.prototype.propertyIsEnumerable.call(e,t)&&(r[t]=e[t])}return r}var o=a.createContext({}),p=function(e){var n=a.useContext(o),t=n;return e&&(t="function"==typeof e?e(n):l(l({},n),e)),t},u=function(e){var n=p(e.components);return a.createElement(o.Provider,{value:n},e.children)},c={inlineCode:"code",wrapper:function(e){var n=e.children;return a.createElement(a.Fragment,{},n)}},d=a.forwardRef((function(e,n){var t=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,u=s(e,["components","mdxType","originalType","parentName"]),d=p(t),m=r,k=d["".concat(o,".").concat(m)]||d[m]||c[m]||i;return t?a.createElement(k,l(l({ref:n},u),{},{components:t})):a.createElement(k,l({ref:n},u))}));function m(e,n){var t=arguments,r=n&&n.mdxType;if("string"==typeof e||r){var i=t.length,l=new Array(i);l[0]=d;var s={};for(var o in n)hasOwnProperty.call(n,o)&&(s[o]=n[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var p=2;p<i;p++)l[p]=t[p];return a.createElement.apply(null,l)}return a.createElement.apply(null,t)}d.displayName="MDXCreateElement"},61520:function(e,n,t){t.r(n),t.d(n,{frontMatter:function(){return s},contentTitle:function(){return o},metadata:function(){return p},toc:function(){return u},default:function(){return d}});var a=t(54570),r=t(89462),i=(t(667),t(96080)),l=["components"],s={},o="dev-c99-mini-idioms",p={unversionedId:"dev-c99-mini-idioms",id:"dev-c99-mini-idioms",title:"dev-c99-mini-idioms",description:"Date: 2025-12-19",source:"@site/docs/dev-c99-mini-idioms.md",sourceDirName:".",slug:"/dev-c99-mini-idioms",permalink:"/docs/dev-c99-mini-idioms",editUrl:"https://github.com/dzharii/dzharii.github.io/docs/dev-c99-mini-idioms.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"dev-c99-libraries",permalink:"/docs/dev-c99-libraries"},next:{title:"dev-c99-recreational-programming",permalink:"/docs/dev-c99-recreational-programming"}},u=[],c={toc:u};function d(e){var n=e.components,t=(0,r.Z)(e,l);return(0,i.kt)("wrapper",(0,a.Z)({},c,t,{components:n,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"dev-c99-mini-idioms"},"dev-c99-mini-idioms"),(0,i.kt)("p",null,"Date: 2025-12-19"),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Zero-initialize scalars and aggregates with ",(0,i.kt)("inlineCode",{parentName:"strong"},"{0}")," (and know what it really does)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int x = 0;\nint a[10] = {0};\nstruct S s = {0};\n")),(0,i.kt)("p",null,"For objects with static storage duration, zero-init happens anyway; for locals, ",(0,i.kt)("inlineCode",{parentName:"p"},"{0}")," forces a full zero fill by the rules for aggregate initialization. It is concise and hard to get wrong."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Designated initializers to document intent and avoid field-order coupling")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'struct Config cfg = {\n    .timeout_ms = 250,\n    .retries = 3,\n    .path = "/tmp/app.sock",\n};\n')),(0,i.kt)("p",null,"This makes changes to ",(0,i.kt)("inlineCode",{parentName:"p"},"struct Config")," safer because you are not relying on declaration order."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Sparse array initialization with designated indices")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int map[256] = { [0 ... 255] = -1, ['A'] = 0, ['B'] = 1 };\n")),(0,i.kt)("p",null,"Range designators (",(0,i.kt)("inlineCode",{parentName:"p"},"[0 ... 255]"),") are a GCC/Clang extension, not C99. The strictly C99 part is designated indices like ",(0,i.kt)("inlineCode",{parentName:"p"},"['A']"),". If you need strict portability, stick to explicit indices."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'Compound literals for "temporary objects with an address"')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"use_point(&(struct Point){ .x = 1, .y = 2 });\n\nmemcpy(dst, (unsigned char[]){0xDE,0xAD,0xBE,0xEF}, 4);\n")),(0,i.kt)("p",null,"Compound literals are standard C99. They are extremely handy for passing small structs/buffers without naming a variable."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Inline constant struct" as a default value without macros')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"static const struct Limits default_limits = { .min = 0, .max = 100 };\n\nstruct Limits lim = default_limits;\n")),(0,i.kt)("p",null,"You get a single source of truth and avoid repeating the initializer."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'Flexible "build up an initializer" with trailing commas')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int xs[] = {\n    1,\n    2,\n    3,\n};\n")),(0,i.kt)("p",null,"C allows the trailing comma. It reduces diffs when adding and removing entries."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Local static for expensive one-time setup inside a function")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'const char *lookup(int k) {\n    static const char *tbl[] = { "zero", "one", "two" };\n    return (k >= 0 && k < (int)(sizeof tbl / sizeof tbl[0])) ? tbl[k] : "unknown";\n}\n')),(0,i.kt)("p",null,"This avoids repeated initialization and keeps the table close to the code that uses it."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Use ",(0,i.kt)("inlineCode",{parentName:"strong"},"sizeof (type){0}")," to get a type size without naming an object")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"size_t n = sizeof (struct Header){0};\n")),(0,i.kt)("p",null,"This is occasionally useful in macros and generic helpers where you do not want an actual variable."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Sentinel at end" arrays for tables of variable length')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'struct KV { const char *k; int v; };\n\nstatic const struct KV kvs[] = {\n    { "alpha", 1 },\n    { "beta", 2 },\n    { 0, 0 },          /* sentinel */\n};\n\nfor (const struct KV *p = kvs; p->k; ++p) { /* ... */ }\n')),(0,i.kt)("p",null,"This avoids separately storing a count and is very readable for static tables."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"enum")," as compile-time integer constants")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"enum { BUF_SZ = 4096, MAX_RETRIES = 5 };\nunsigned char buf[BUF_SZ];\n")),(0,i.kt)("p",null,"Unlike macros, ",(0,i.kt)("inlineCode",{parentName:"p"},"enum")," constants participate in the language and show up better in debuggers."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'Counted push with post-increment (your pattern) plus the "guard" form')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"if (array_count < ARRAY_CAP) {\n    array[array_count++] = value;\n}\n")),(0,i.kt)("p",null,"The idiom is best when paired with an explicit bounds guard close by."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Iterate pointers over arrays (often cleaner than indices)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"for (int *p = a, *e = a + n; p != e; ++p) {\n    *p += 1;\n}\n")),(0,i.kt)("p",null,"You avoid repeated indexing arithmetic and it composes well with subranges."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Two-pointer" walk for in-place filtering/compaction')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"size_t w = 0;\nfor (size_t r = 0; r < n; ++r) {\n    if (keep(xs[r])) xs[w++] = xs[r];\n}\nn = w;\n")),(0,i.kt)("p",null,"This is the simplest correct in-place filter pattern."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Reverse loop without unsigned underflow traps")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"for (size_t i = n; i-- > 0; ) {\n    /* uses i = n-1 down to 0 */\n}\n")),(0,i.kt)("p",null,"This avoids ",(0,i.kt)("inlineCode",{parentName:"p"},"i >= 0")," (which is always true for ",(0,i.kt)("inlineCode",{parentName:"p"},"size_t"),") and avoids underflow bugs."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Advance before use" scanning with assignment in the condition')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int c;\nwhile ((c = *p++) != 0) {\n    /* use c */\n}\n")),(0,i.kt)("p",null,"This compresses scanning code, and ensures the increment is not accidentally duplicated."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Parse with ",(0,i.kt)("inlineCode",{parentName:"strong"},"strtol")," and keep the end pointer in the loop header")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"for (char *p = s; *p; ) {\n    char *end;\n    long v = strtol(p, &end, 10);\n    if (end == p) break;     /* no progress */\n    /* use v */\n    p = end;\n}\n")),(0,i.kt)("p",null,"This is a robust skeleton for numeric tokenization."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Loop that guarantees at least one iteration" with ',(0,i.kt)("inlineCode",{parentName:"strong"},"do { } while (0)")," (not just for macros)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"do {\n    if (!init()) break;\n    if (!step()) break;\n    finish();\n} while (0);\n")),(0,i.kt)("p",null,"It reads like structured early-exit without introducing ",(0,i.kt)("inlineCode",{parentName:"p"},"goto")," yet."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Switch-driven state machine with intentional fallthrough")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"switch (state) {\ncase S_START:\n    /* ... */\n    state = S_BODY;\n    /* fall through */\ncase S_BODY:\n    /* ... */\n    break;\n}\n")),(0,i.kt)("p",null,"The convenience is real, but comment intentional fallthrough because compilers warn and humans misread."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'The canonical "walk a C string" pointer loop')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"for (const unsigned char *p = (const unsigned char *)s; *p; ++p) {\n    /* ... */\n}\n")),(0,i.kt)("p",null,"Using ",(0,i.kt)("inlineCode",{parentName:"p"},"unsigned char")," avoids undefined behavior with the ctype family when chars are negative."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"ctype functions: cast to unsigned char, and do not pass pointers")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"if (isalpha((unsigned char)c)) { /* ... */ }\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"isalpha(0)")," is defined to be false in the C locale, so ",(0,i.kt)("inlineCode",{parentName:"p"},"isalpha('\\0')")," is fine. Passing ",(0,i.kt)("inlineCode",{parentName:"p"},"NULL"),' is not "special"; it is just ',(0,i.kt)("inlineCode",{parentName:"p"},"0")," as an integer constant, but treating it as a pointer concept is misleading. The real pitfall is ",(0,i.kt)("inlineCode",{parentName:"p"},"isalpha((signed char)0xE9)")," which can be negative and is undefined unless you cast to ",(0,i.kt)("inlineCode",{parentName:"p"},"unsigned char")," (or pass EOF)."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"memchr"),' as a fast "find delimiter in bytes"')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"const unsigned char *q = memchr(p, '\\n', (size_t)(end - p));\nif (q) { /* found */ }\n")),(0,i.kt)("p",null,"Useful for scanning non-null-terminated buffers, unlike ",(0,i.kt)("inlineCode",{parentName:"p"},"strchr"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Length-limited string scan" without copying')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"size_t i = 0;\nfor (; i < n && buf[i] != '\\0'; ++i) { /* ... */ }\n")),(0,i.kt)("p",null,"This is the safe pattern for possibly unterminated data."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"snprintf")," for bounded formatting and detecting truncation")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'int m = snprintf(dst, dst_sz, "%s/%s", a, b);\nif (m < 0 || (size_t)m >= dst_sz) { /* truncated or error */ }\n')),(0,i.kt)("p",null,"The return value is the size that would have been written, which makes it easy to size buffers."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Append pointer" pattern for building strings efficiently')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'char out[256];\nchar *w = out;\nchar *e = out + sizeof out;\n\nw += snprintf(w, (size_t)(e - w), "x=%d ", x);\nw += snprintf(w, (size_t)(e - w), "y=%d", y);\n')),(0,i.kt)("p",null,"This keeps the write position explicit and avoids repeated ",(0,i.kt)("inlineCode",{parentName:"p"},"strlen"),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Tokenize without ",(0,i.kt)("inlineCode",{parentName:"strong"},"strtok")," by using ",(0,i.kt)("inlineCode",{parentName:"strong"},"strcspn")," and manual slicing")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'for (char *p = s; *p; ) {\n    p += strspn(p, " \\t");\n    size_t len = strcspn(p, " \\t");\n    if (len == 0) break;\n    /* token is p..p+len */\n    p += len;\n}\n')),(0,i.kt)("p",null,"No global state, re-entrant, and it works with custom delimiters."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Single-exit cleanup with ",(0,i.kt)("inlineCode",{parentName:"strong"},"goto"))," "),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'int f(void) {\n    int rc = -1;\n    FILE *fp = 0;\n    void *buf = 0;\n\n    fp = fopen("x", "rb");\n    if (!fp) goto out;\n\n    buf = malloc(4096);\n    if (!buf) goto out;\n\n    rc = 0;\nout:\n    free(buf);\n    if (fp) fclose(fp);\n    return rc;\n}\n')),(0,i.kt)("p",null,"This scales when you add resources; you do not multiply cleanup code."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Return value capture" so you do not lose error information')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int rc = do_work();\nif (rc) return rc;\n")),(0,i.kt)("p",null,"Simple, but the important part is: never overwrite ",(0,i.kt)("inlineCode",{parentName:"p"},"rc")," before you have consumed it."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Preserve ",(0,i.kt)("inlineCode",{parentName:"strong"},"errno")," across cleanup that might clobber it")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int saved = errno;\n/* cleanup that might call functions touching errno */\nerrno = saved;\nreturn -1;\n")),(0,i.kt)("p",null,"This matters when callers use ",(0,i.kt)("inlineCode",{parentName:"p"},"errno")," to diagnose the original failure."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"fgets")," loop with newline trimming in one place")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"while (fgets(line, sizeof line, fp)) {\n    line[strcspn(line, \"\\n\")] = '\\0';\n    /* use line */\n}\n")),(0,i.kt)("p",null,"This avoids repeated ad hoc newline logic."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Close on success, free on failure" with ownership transfer')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"char *buf = malloc(n);\nif (!buf) return -1;\n\n*out = buf;   /* transfer ownership */\nbuf = 0;      /* prevent accidental free */\nreturn 0;\n")),(0,i.kt)("p",null,"Setting the local to 0 after transfer prevents double-free in a shared cleanup block."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The do-while(0) macro wrapper so statements behave like statements")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#define CHECK(x) do { if (!(x)) return -1; } while (0)\n")),(0,i.kt)("p",null,"This prevents surprises with ",(0,i.kt)("inlineCode",{parentName:"p"},"if (cond) CHECK(...); else ..."),"."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Compile-time array count (only works for actual arrays)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#define ARRAY_LEN(a) (sizeof(a) / sizeof((a)[0]))\n")),(0,i.kt)("p",null,"Use it only when you truly have an array, not a pointer."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Static assert" in C99 via typedef trick (portable)')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#define STATIC_ASSERT(expr) typedef char static_assertion[(expr) ? 1 : -1]\nSTATIC_ASSERT(sizeof(int) == 4);\n")),(0,i.kt)("p",null,"C11 has ",(0,i.kt)("inlineCode",{parentName:"p"},"_Static_assert"),", but this works in C99 and fails at compile time."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Stringize and concatenate for generating names and messages")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'#define STR_(x) #x\n#define STR(x) STR_(x)\n\n#define CAT_(a,b) a##b\n#define CAT(a,b) CAT_(a,b)\n\nint CAT(tmp_, __LINE__);\nconst char *msg = "line " STR(__LINE__);\n')),(0,i.kt)("p",null,"These are building blocks for debugging macros and generated identifiers."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"X-macro tables: one list, many derived artifacts")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'/* list */\n#define COLORS(X) \\\n    X(RED)        \\\n    X(GREEN)      \\\n    X(BLUE)\n\n/* enum */\n#define X(name) name,\nenum Color { COLORS(X) };\n#undef X\n\n/* to-string */\n#define X(name) case name: return #name;\nconst char *color_name(enum Color c) {\n    switch (c) { COLORS(X) default: return "?"; }\n}\n#undef X\n')),(0,i.kt)("p",null,"This avoids keeping enum, strings, and other metadata in sync by hand."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Optional debug logging compiled out cleanly")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#ifdef DEBUG\n#define LOG(...) fprintf(stderr, __VA_ARGS__)\n#else\n#define LOG(...) ((void)0)\n#endif\n")),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"((void)0)")," keeps expression contexts well-typed."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Check for overflow before multiply/add (portable pattern)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"if (b != 0 && a > SIZE_MAX / b) return -1;   /* a*b would overflow */\n\nif (a > SIZE_MAX - b) return -1;            /* a+b would overflow */\n")),(0,i.kt)("p",null,"This is the reliable, standard way (no compiler builtins)."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Align up/down with power-of-two alignment (common, but easy to botch)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"size_t align_up(size_t x, size_t a) { return (x + (a - 1)) & ~(a - 1); }\nsize_t align_dn(size_t x, size_t a) { return x & ~(a - 1); }\n")),(0,i.kt)("p",null,"Only valid when ",(0,i.kt)("inlineCode",{parentName:"p"},"a")," is a power of two."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Bitset membership with unsigned shifts (avoid UB on signed)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"unsigned mask = 1u << bit;\nif (flags & mask) { /* set */ }\n")),(0,i.kt)("p",null,"Use unsigned types for bit operations; left shift on signed can be undefined."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'Branchless "is power of two" (and exclude 0)')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int is_pow2(size_t x) { return x && ((x & (x - 1)) == 0); }\n")),(0,i.kt)("p",null,"Tiny and used often in allocators and alignment code."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Byte extraction with masks and shifts (portable endianness-agnostic logic)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"unsigned byte0 = (x >> 0) & 0xFFu;\nunsigned byte1 = (x >> 8) & 0xFFu;\n")),(0,i.kt)("p",null,"This avoids aliasing and alignment pitfalls of pointer casts."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Allocate using the pointed-to type, not repeating the type name")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"T *p = malloc(sizeof *p);\np = realloc(p, new_count * sizeof *p);\n")),(0,i.kt)("p",null,"This survives type changes and reduces mismatch errors."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"realloc")," with a temporary to avoid losing the original pointer on failure")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"void *tmp = realloc(p, n);\nif (!tmp) { /* p still valid */ return -1; }\np = tmp;\n")),(0,i.kt)("p",null,"This is one of the highest-value C habits you can adopt."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Zero-initialize heap objects with ",(0,i.kt)("inlineCode",{parentName:"strong"},"calloc")," when it matches the semantics")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"T *p = calloc(count, sizeof *p);\n")),(0,i.kt)("p",null,'It communicates "I want zeroed memory" and can be optimized by the runtime.'),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Memset a struct via its address, not by casting")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"memset(&s, 0, sizeof s);\n")),(0,i.kt)("p",null,"Straightforward, but still the correct idiom when ",(0,i.kt)("inlineCode",{parentName:"p"},"{0}")," is not possible."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Strict aliasing safe type-punning: use ",(0,i.kt)("inlineCode",{parentName:"strong"},"memcpy"),", not pointer casts")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"float f;\nuint32_t u;\nmemcpy(&u, &f, sizeof u);\n")),(0,i.kt)("p",null,"Pointer-cast punning can break under optimization; ",(0,i.kt)("inlineCode",{parentName:"p"},"memcpy")," is the portable way."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Flexible array member" for variable-sized structs (C99 feature)')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"struct Msg {\n    uint32_t len;\n    unsigned char data[];   /* flexible array */\n};\n\nstruct Msg *m = malloc(sizeof *m + payload_len);\nm->len = payload_len;\nmemcpy(m->data, payload, payload_len);\n")),(0,i.kt)("p",null,"This keeps header and payload contiguous and cache-friendly."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Container-of pattern (common, but not standard-library provided)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#define OFFSETOF(type, member) ((size_t)&(((type *)0)->member))\n#define CONTAINER_OF(ptr, type, member) ((type *)((char *)(ptr) - OFFSETOF(type, member)))\n")),(0,i.kt)("p",null,"Useful for intrusive data structures. It relies on well-known idioms, but it is also sharp: use only when you fully control types and lifetimes."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Return error code, write outputs through pointers")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int parse(const char *s, struct Result *out);\n")),(0,i.kt)("p",null,"Callers can stack-allocate ",(0,i.kt)("inlineCode",{parentName:"p"},"struct Result")," and you avoid heap ownership questions."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Optional output" pointers with a simple guard')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"if (out_value) *out_value = v;\n")),(0,i.kt)("p",null,"This gives callers flexibility without multiplying function variants."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Size-in, size-out for buffers (and report required size)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int encode(char *dst, size_t dst_sz, size_t *out_sz);\n")),(0,i.kt)("p",null,"On overflow, set ",(0,i.kt)("inlineCode",{parentName:"p"},"*out_sz")," to the needed size and return an error."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Use ",(0,i.kt)("inlineCode",{parentName:"strong"},"const")," to document and enforce read-only inputs")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int hash(const void *data, size_t n, uint32_t *out);\n")),(0,i.kt)("p",null,"This eliminates entire classes of accidental mutation bugs."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"User data" callbacks (poor man\'s closures)')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"typedef int (*visit_fn)(void *user, const struct Node *n);\n\nint walk(const struct Node *root, visit_fn fn, void *user);\n")),(0,i.kt)("p",null,"This is the idiomatic C way to carry context into callbacks."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"sscanf")," is tempting, but ",(0,i.kt)("inlineCode",{parentName:"strong"},"strto*")," with end pointers composes better")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"char *end;\nlong v = strtol(p, &end, 10);\nif (end == p) { /* not a number */ }\np = end;\n")),(0,i.kt)("p",null,"This avoids format-string corner cases and gives you precise control."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Use scansets in ",(0,i.kt)("inlineCode",{parentName:"strong"},"sscanf")," when you really do want it (bounded)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"char key[32];\nif (sscanf(line, \"%31[^=]=%*s\", key) == 1) { /* key before '=' */ }\n")),(0,i.kt)("p",null,"The width prevents buffer overflow; the scanset is a powerful but underused feature."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Trim in place" with two indices/pointers')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"char *p = s;\nwhile (*p == ' ' || *p == '\\t') ++p;\n\nchar *e = p + strlen(p);\nwhile (e > p && (e[-1] == ' ' || e[-1] == '\\t' || e[-1] == '\\n')) --e;\n*e = '\\0';\n\nif (p != s) memmove(s, p, (size_t)(e - p) + 1);\n")),(0,i.kt)("p",null,"This is a reusable skeleton for whitespace trimming without allocating."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Print ",(0,i.kt)("inlineCode",{parentName:"strong"},"size_t")," and pointers correctly")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'printf("n=%zu\\n", n);\nprintf("p=%p\\n", (void *)p);\n')),(0,i.kt)("p",null,"These format specifiers prevent subtle UB and portability bugs."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Use ",(0,i.kt)("inlineCode",{parentName:"strong"},"__FILE__")," and ",(0,i.kt)("inlineCode",{parentName:"strong"},"__LINE__")," for trace points")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'fprintf(stderr, "%s:%d: failed\\n", __FILE__, __LINE__);\n')),(0,i.kt)("p",null,"This is a low-tech, high-value breadcrumb."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Hex dump loop that is careful about signedness")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},'const unsigned char *b = buf;\nfor (size_t i = 0; i < n; ++i) printf("%02X", (unsigned)b[i]);\n')),(0,i.kt)("p",null,"Casting avoids ",(0,i.kt)("inlineCode",{parentName:"p"},"char")," sign surprises."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"The comma operator for tight loops (use sparingly)")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"for (i = 0, p = a; i < n; ++i, ++p) { /* ... */ }\n")),(0,i.kt)("p",null,"It is idiomatic in C, but readability drops if you overpack logic into the header."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'Assignment in condition to express "read then test"')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"while ((n = fread(buf, 1, sizeof buf, fp)) != 0) { /* ... */ }\n")),(0,i.kt)("p",null,"This is one of the clearest uses of assignment-in-condition: it matches the control flow of I/O."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Boolean normalization with ",(0,i.kt)("inlineCode",{parentName:"strong"},"!!"))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"int ok = !!ptr;\n")),(0,i.kt)("p",null,"Forces a clean 0/1 value, useful when you need strict boolean-like integers."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"Swap via temporary" plus the macro version (evaluate once)')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"#define SWAP(a,b) do { __typeof__(a) _t = (a); (a) = (b); (b) = _t; } while (0)\n")),(0,i.kt)("p",null,"The macro version above uses ",(0,i.kt)("inlineCode",{parentName:"p"},"__typeof__"),", which is a GNU extension, not C99. In strict C99, you typically hand-write swaps or use a function specialized per type."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"offsetof")," from ",(0,i.kt)("inlineCode",{parentName:"strong"},"<stddef.h>")," for layout-aware code")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"size_t off = offsetof(struct S, member);\n")),(0,i.kt)("p",null,"This is standard and safer than home-grown offset macros."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},(0,i.kt)("inlineCode",{parentName:"strong"},"volatile"),' only for hardware/async boundaries, not for "thread safety"')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"volatile uint32_t *reg = (volatile uint32_t *)0x40000000u;\n*reg = 1;\n")),(0,i.kt)("p",null,"This is a pattern you see in embedded C; the key is knowing that ",(0,i.kt)("inlineCode",{parentName:"p"},"volatile")," is not a concurrency primitive."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Use ",(0,i.kt)("inlineCode",{parentName:"strong"},"restrict")," (C99) when you can prove non-aliasing")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"void saxpy(float *restrict y, const float *restrict x, size_t n, float a);\n")),(0,i.kt)("p",null,"It can unlock optimizations and documents a strong contract."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},'"One definition of a flag set" via an enum and bit masks')),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-c"},"enum {\n    F_READ  = 1u << 0,\n    F_WRITE = 1u << 1,\n    F_EXEC  = 1u << 2,\n};\n")),(0,i.kt)("p",null,"This is a clean, debugger-friendly alternative to raw ",(0,i.kt)("inlineCode",{parentName:"p"},"#define")," flags."))}d.isMDXComponent=!0}}]);